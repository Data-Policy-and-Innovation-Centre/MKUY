---
title: "Analysis_3"
author: "Sanchit"
date: "2024-08-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "C:/Users/Admin/Box/1. Agriculture Odisha/5. MKUY/8. Sanchit/Outputs")

```


```{r}
library(openxlsx)
```


# Modificatons to the ppt MKUY Analysis_v2 after discussion with Urmila

Slide 0: Add a 'slide 0' with features of the MKUY scheme. Describing the subsidy eligibility, amount, etc.
Slide 1: Mostly the same. Add that 'analysis captures all live projects'
Slide 2:  
  1. Simplify the statements
  2. Mention what 'groups', 'enterprises' are
  3. Include statements only on social groups, gender, type of ownership and sectors
  4. Mention what 'Rest' mean in sectors
  5. Note for abbreviations used
Slide 3: 
  1. 'All districts captured under MKUY'
  2. 'Concentration in the northern and eastern districts'
  3. Consistency of district names
  4. Find out cutoffs for the heat map for blocks
  5. 'Projects are spatially co-located in terms of blocks within districts'
Slide 4: 
  1. Remove the stacks for sectors
Slide 5: 
  1. Mention 'live projects'
  2. 
Slide 6: Remove it
Slide 7: 
  1. Make two graphs excluding stacks for sectors - General (Applicants eligible for 40 per cent subsidy) and Special (Rest of the applicants) {Code}
  2. Use fixed costs instead of project costs
  3. Hypothesis: 'General category apply for bigger projects', 'There are variations on the basis of these categories'
  4. Make two more graphs on the same classifications but with project sectors and not fixed cost ranges {Code}
  5. Look at spatial distribution of projects but not with any classifications, but just for large projects {Code}
  6. Make the same fixed cost ranges graphs with modifications to the ranges (0-50, 50-1, and above 1) {Code}
New slide before slide 8: 
  1. Ratio of fixed cost to project cost by sectors {Code}
Slide 8: 
  1. Replace the stacked bar plot for mode of finance with two pie charts for fixed cost size, sectors. {Code}
  
Further Investigation within the frame of General vs Special:
  1. Investigate the above 1 crore projects- by location, mode of finance, sector {Code}
  2. Do the same above with projects below 25 lakhs {Code}
  3. Look at variations of fixed costs by sector, types, etc. {Code}
  
  
###############################################################################################################  
  
  









# Slide 7: 
  1. Make two graphs excluding stacks for sectors - General (Applicants eligible for 40 per cent subsidy) and Special (Rest of the applicants) {Code}
  2. Use fixed costs instead of project costs
  3. Hypothesis: 'General category apply for bigger projects', 'There are variations on the basis of these categories'
  4. Make two more graphs on the same classifications but with project sectors and not fixed cost ranges {Code}
  5. Look at spatial distribution of projects but not with any classifications, but just for large projects {Code}
  6. Make the same fixed cost ranges graphs with modifications to the ranges (0-50, 50-1, and above 1) {Code}



## 1. Make two graphs excluding stacks for sectors - General (Applicants eligible for 40 per cent subsidy) and Special (Rest of the applicants) {Code} 

Data frame
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}

library(dplyr)
library(tidyr)



# Create 'fixed_cost_range' using the specified breaks and labels, and exclude NA values
df_clean_filtered <- df_clean %>%
  filter(!is.na(fixed_cost) & !is.na(general)) %>%  # Exclude NA values
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 2500000, 5000000, 10000000, Inf),
                                labels = c("Below 25 lakhs", "25-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                right = FALSE))

# Create a summary data frame with counts of projects, structured with 'fixed_cost_range' as the first column
summary_df <- df_clean_filtered %>%
  group_by(fixed_cost_range, general) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  pivot_wider(names_from = general, values_from = Count, values_fill = 0) %>%
  ungroup()

# Calculate total counts within each fixed cost range
summary_df <- summary_df %>%
  group_by(fixed_cost_range) %>%
  mutate(total_range = Special + General) %>%
  ungroup()

# Add percentages in brackets for each fixed cost range
summary_df <- summary_df %>%
  mutate(Special = paste0(Special, " (", round((Special / total_range) * 100, 1), "%)"),
         General = paste0(General, " (", round((General / total_range) * 100, 1), "%)")) %>%
  select(fixed_cost_range, Special, General)  # Select only relevant columns

# Display the summary data frame
print(summary_df)

# Define the file path and name
file_path_3 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\size_share_category.xlsx"

# Export the data frame to Excel
write_xlsx(summary_df, path = file_path_3)

```
  
Bar Plot
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(ggplot2)
library(dplyr)

# Convert the counts (with percentages) back to numeric for plotting
summary_df$Special_count <- as.numeric(gsub(" \\(.*\\)", "", summary_df$Special))
summary_df$General_count <- as.numeric(gsub(" \\(.*\\)", "", summary_df$General))

# Reshape the data for easier plotting with faceting
plot_df <- summary_df %>%
  select(fixed_cost_range, Special_count, General_count) %>%
  pivot_longer(cols = c(Special_count, General_count),
               names_to = "Category",
               values_to = "Count") %>%
  mutate(Category = recode(Category, "Special_count" = "Special", "General_count" = "General"))

# Create the bar plots with a common y-axis using facet_wrap
plot_Int_1 <- ggplot(plot_df, aes(x = fixed_cost_range, y = Count, fill = fixed_cost_range)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Count), vjust = -0.5) +
  labs(title = "Number of Projects by Fixed Cost Ranges",
       x = "Fixed Cost Ranges",
       y = "Count of Projects") +
  theme_minimal() +
  theme(legend.position = "none") +  # Hide legend since it's redundant
  facet_wrap(~ Category)  # Separate plots for Special and General

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Int_Plots\\Plot_Int_1.png", 
       plot = plot_Int_1, width = 12, height = 10, dpi = 300)


```
  



 
## 4. Make two more graphs on the same classifications but with project sectors and not fixed cost ranges {Code}

Data frame  
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}

# Create 'project_sector' summary data frame
summary_df_sector <- df_clean %>%
  filter(!is.na(project_sector) & !is.na(general)) %>%  # Exclude NA values
  group_by(project_sector, general) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  pivot_wider(names_from = general, values_from = Count, values_fill = 0)  # Restructure the data frame

# Calculate total projects
total_projects_sector <- sum(summary_df_sector$Special + summary_df_sector$General)

# Add percentages in brackets
summary_df_sector <- summary_df_sector %>%
  mutate(Special = paste0(Special, " (", round((Special / sum(summary_df_sector$Special)) * 100, 1), "%)"),
         General = paste0(General, " (", round((General / sum(summary_df_sector$General)) * 100, 1), "%)"))

# Extract numeric counts from the Special and General columns
summary_df_sector_numeric <- summary_df_sector %>%
  mutate(Special_count = as.numeric(gsub(" \\(.*\\)", "", Special)),
         General_count = as.numeric(gsub(" \\(.*\\)", "", General))) %>%
  arrange(desc(Special_count))  # Sort by Special_count

# Display the summary data frame
summary_df_sector_numeric
# Define the file path and name
file_path <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\sector_share_category.xlsx"

# Export the data frame to Excel
write_xlsx(summary_df_sector_wide, path = file_path)


```

Plot
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(dplyr)
library(ggplot2)
library(gridExtra)

# Step 1: Create 'Rest of the Sectors' category and summarize the data
summary_df_sector <- df_clean %>%
  filter(!is.na(project_sector) & !is.na(general)) %>%
  mutate(project_sector_grouped = case_when(
    project_sector %in% c("AH&VS Sector", "Agriculture Sector", "Horticulture Sector") ~ project_sector,
    TRUE ~ "Rest of the Sectors"
  )) %>%
  group_by(project_sector_grouped, general) %>%
  summarise(Count = n(), .groups = 'drop')

# Step 2: Reshape data to wide format and arrange sectors
summary_df_sector_wide <- summary_df_sector %>%
  pivot_wider(names_from = general, values_from = Count, values_fill = 0) %>%
  mutate(Total = General + Special) %>%
  arrange(desc(Total))  # Arrange by Total counts

# Step 3: Adjust factor levels so 'Rest of the Sectors' is last
summary_df_sector_wide$project_sector_grouped <- factor(summary_df_sector_wide$project_sector_grouped,
                                                        levels = c(unique(summary_df_sector_wide$project_sector_grouped[summary_df_sector_wide$project_sector_grouped != "Rest of the Sectors"]),
                                                                   "Rest of the Sectors"))

# Calculate total General and Special projects for percentages
total_general <- sum(summary_df_sector_wide$General)
total_special <- sum(summary_df_sector_wide$Special)

# Step 3: Add labels with counts and percentages
summary_df_sector_wide <- summary_df_sector_wide %>%
  mutate(General_label = paste0(General, " (", round((General / total_general) * 100, 1), "%)"),
         Special_label = paste0(Special, " (", round((Special / total_special) * 100, 1), "%)"))

# Step 4: Determine common y-axis limit
y_limit <- max(summary_df_sector_wide$General, summary_df_sector_wide$Special)

# Step 5: Plotting 'General' Category
plot_general <- ggplot(summary_df_sector_wide, aes(x = reorder(project_sector_grouped, -Total), y = General, fill = project_sector_grouped)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = General_label), vjust = -0.5, color = "black") +
  labs(title = "General",
       x = "",
       y = "Project Count") +
  ylim(0, y_limit * 1.1) +  # Set common y-axis limit
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1))

# Step 6: Plotting 'Special' Category
plot_special <- ggplot(summary_df_sector_wide, aes(x = reorder(project_sector_grouped, -Total), y = Special, fill = project_sector_grouped)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = Special_label), vjust = -0.5, color = "black") +
  labs(title = "Special",
       x = "",
       y = "Project Count") +
  ylim(0, y_limit * 1.1) +  # Set common y-axis limit
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 1))

# Step 7: Display plots side by side
plot_Int_2 <- grid.arrange(plot_general, plot_special, ncol = 2, top = "Counts of Projects by Sector")

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Int_Plots\\Plot_Int_2.png", 
       plot = plot_Int_2, width = 12, height = 10, dpi = 300)


print(summary_df_sector_wide)


library(writexl)
# Define the file path and name
file_path <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\sector_share.xlsx"

# Export the data frame to Excel
write_xlsx(summary_df_sector_wide, path = file_path)



```

 Pie charts for the same graph 
```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Create pie chart for 'General' category
plot_general_pie <- ggplot(summary_df_sector_wide, aes(x = "", y = General, fill = project_sector_grouped)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  geom_text(aes(label = General_label), position = position_stack(vjust = 0.5)) +
  labs(title = "General") +
  theme_void() +  # Removes axes, gridlines, and background
  theme(legend.position = "right")

# Create pie chart for 'Special' category
plot_special_pie <- ggplot(summary_df_sector_wide, aes(x = "", y = Special, fill = project_sector_grouped)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  geom_text(aes(label = Special_label), position = position_stack(vjust = 0.5)) +
  labs(title = "Special") +
  theme_void() +  # Removes axes, gridlines, and background
  theme(legend.position = "right")

# Display the pie charts side by side
plot_pie_charts <- grid.arrange(plot_general_pie, plot_special_pie, ncol = 2, top = "Counts of Projects by Sector")

# Display the combined plot
print(plot_pie_charts)

```
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
## 5. Look at spatial distribution of projects but not with any classifications, but just for large projects (above 1 crore) {Code}
  
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup', error=FALSE}

library(dplyr)

library(dplyr)

# Filter projects with fixed_cost above 1 crore
projects_above_1_crore <- df_clean %>%
  filter(fixed_cost > 10000000) %>%
  group_by(district) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(desc(count))  # Arrange in descending order by count

# Calculate the total count of projects
total_count <- projects_above_1_crore %>%
  summarise(count = sum(count)) %>%
  mutate(district = "Total")

# Combine the original data frame with the total row
projects_above_1_crore_with_total <- bind_rows(projects_above_1_crore, total_count)

# Display the updated summary data frame
print(projects_above_1_crore_with_total)


file_path_4 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\Above1crore.xlsx"

# Export the data frame to Excel
write_xlsx(projects_above_1_crore_with_total, path = file_path_4)













# Define 'general' based on 'caste' and 'gender'
df_clean <- df_clean %>%
  mutate(general = ifelse(!is.na(caste) & !is.na(gender) & 
                           caste == "General" & gender == "Male", "General", "Special"))

# Ensure 'general' is treated as a factor
df_clean <- df_clean %>%
  mutate(general = factor(general, levels = c("General", "Special")))

# Filter projects with fixed_cost above 1 crore
projects_above_1_crore_summary <- df_clean %>%
  filter(fixed_cost > 10000000, !is.na(general), !is.na(mode_of_finance)) %>%
  group_by(general, mode_of_finance) %>%
  summarise(count = n(), .groups = 'drop') %>%
  # Calculate total counts and percentages
  group_by(general) %>%
  mutate(total = sum(count),
         percentage = round((count / total) * 100, 1)) %>%
  # Create a label for display
  mutate(label = paste0(count, " (", percentage, "%)")) %>%
  # Pivot to wide format
  pivot_wider(names_from = mode_of_finance, values_from = count, values_fill = 0) %>%
  # Add total row
  bind_rows(
    df_clean %>%
      filter(fixed_cost > 10000000, !is.na(mode_of_finance)) %>%
      group_by(mode_of_finance) %>%
      summarise(count = n(), .groups = 'drop') %>%
      mutate(general = "Total") %>%
      pivot_wider(names_from = mode_of_finance, values_from = count, values_fill = 0)
  ) %>%
  arrange(general)

# Display the resulting data frame
print(projects_above_1_crore_summary)



library(dplyr)

# Filter for GANJAM district and projects with fixed_cost above 1 crore
ganjam_projects_above_1_crore <- df_clean %>%
  filter(district == "GANJAM" & fixed_cost > 10000000) %>%
  # Summarize counts by project sector
  group_by(project_sector) %>%
  summarise(count = n(), .groups = 'drop') %>%
  # Calculate percentage if needed
  mutate(percentage = round((count / sum(count)) * 100, 1))

# Display the resulting data frame
print(ganjam_projects_above_1_crore)





# Filter df_clean for the 5th level of 'project_sector' and get unique values of 'project_type'
unique_values_table <- df_clean %>%
  filter(project_sector == levels(project_sector)[5]) %>% 
  filter(district == levels(district)[11]) %>% 
  group_by(project_type) %>%  # Group by 'project_type'
  summarise(count = n(), .groups = 'drop') %>%  # Count the number of occurrences of each type
  arrange(desc(count))  # Optionally, arrange by count in descending order

# Display the unique values table
print(unique_values_table)

```

#Map for projects above one crore

Merging data
```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Load necessary packages
library(dplyr)

# Direct join by district
direct_joined_data <- projects_above_1_crore %>%
  left_join(odisha_districts, by = "district")

# Display the result of the direct join
print(direct_joined_data)




```



Map (Incomplete)
```{r}
# Ensure count is numeric
merged_data$count <- as.numeric(merged_data$count)

library(ggplot2)
library(scales)

# Define the color scale with a gradient from light yellow to red
color_scale <- scale_fill_gradient(
  low = "lightyellow",  # Color for low values
  high = "red",         # Color for high values
  na.value = "grey90",  # Color for NA values
  name = "Count of Projects",
  breaks = pretty_breaks(n = 5),  # Adjust number of breaks as needed
  labels = scales::comma  # Format labels for readability
)

plot_Int_3 <- ggplot(direct_joined_data) +
  geom_sf(aes(fill = count), color = "black", size = 0.2) +
  color_scale +  # Apply the custom color scale
  geom_sf_text(aes(label = paste0(district, "\n(", count, ")")), size = 3, color = "black", check_overlap = TRUE) +  # Add district labels with count
  labs(title = "Projects Above 1 Crore") +
  theme_void() +  # Remove axes and labels
  theme(legend.position = "right")

print(plot_Int_3)
# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Int_Plots\\Plot_Int_3.png", 
       plot = plot_Int_3, width = 12, height = 10, dpi = 300)

print(plot_Int_3)
```




Bar Plot of districts with projects above 1 crore
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)

# Remove the 'Total' row from the data frame
projects_above_1_crore_no_total <- projects_above_1_crore_with_total %>%
  filter(district != "Total")

# Create the bar plot with count labels
plot_Int_6 <- ggplot(projects_above_1_crore_no_total, aes(x = reorder(district, count), y = count, fill = district)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = count), hjust = -0.3, size = 3.5) +  # Add labels for counts
  coord_flip() +  # Flip the coordinates for a horizontal bar plot
  labs(title = "Number of Projects with Fixed Cost Above 1 Crore by District",
       x = "District",
       y = "Number of Projects") +
  theme_minimal() +
  theme(legend.position = "none")  # Remove the legend as it's not needed

# Display the plot
print(ggplot)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Int_Plots\\Plot_Int_6.png", 
       plot = plot_Int_6, width = 12, height = 10, dpi = 300)

print(plot_Int_6)

```




  
## 6. Make the same fixed cost ranges graphs with modifications to the ranges (0-50, 50-1, and above 1) {Code}
  
Data Frame

```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Ensure 'general' is a factor variable
df_clean$general <- factor(df_clean$general, labels = c("Special", "General"))

# Create 'fixed_cost_range' using the specified breaks and labels, and exclude NA values
df_clean_filtered <- df_clean %>%
  filter(!is.na(fixed_cost) & !is.na(general)) %>%  # Exclude NA values
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 5000000, 10000000, Inf),
                                labels = c("Below 50 lakhs", "50 lakhs-1 crore", "above 1 crore"),
                                right = FALSE))

# Create a summary data frame with counts of projects, structured with 'fixed_cost_range' as the first column
summary_df_2 <- df_clean_filtered %>%
  group_by(fixed_cost_range, general) %>%
  summarise(Count = n()) %>%
  ungroup() %>%
  pivot_wider(names_from = general, values_from = Count, values_fill = 0)  # Restructure the data frame

# Calculate total projects
total_projects <- sum(summary_df_2$Special + summary_df_2$General)

# Add percentages in brackets
summary_df_2 <- summary_df_2 %>%
  mutate(Special = paste0(Special, " (", round((Special / total_projects) * 100, 1), "%)"),
         General = paste0(General, " (", round((General / total_projects) * 100, 1), "%)"))

# Display the summary data frame
summary_df_2
```


Bar Plot 
  
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Convert the counts (with percentages) back to numeric for plotting
summary_df_2$Special_count <- as.numeric(gsub(" \\(.*\\)", "", summary_df_2$Special))
summary_df_2$General_count <- as.numeric(gsub(" \\(.*\\)", "", summary_df_2$General))

# Reshape the data for easier plotting with faceting
plot_df <- summary_df_2 %>%
  select(fixed_cost_range, Special_count, General_count) %>%
  pivot_longer(cols = c(Special_count, General_count),
               names_to = "Category",
               values_to = "Count") %>%
  mutate(Category = recode(Category, "Special_count" = "Special", "General_count" = "General"))

# Create the bar plots with a common y-axis using facet_wrap
ggplot(plot_df, aes(x = fixed_cost_range, y = Count, fill = fixed_cost_range)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Count), vjust = -0.5) +
  labs(title = "Project Counts by Fixed Cost Range and Category",
       x = "Fixed Cost Range",
       y = "Count of Projects") +
  theme_minimal() +
  theme(legend.position = "none") +  # Hide legend since it's redundant
  facet_wrap(~ Category)  # Separate plots for Special and General
```
  
  
 ######################################################################################### 
  
  
# New slide before slide 8: Ratio of fixed cost to project cost by sectors {Code}  

Data Frame  
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(dplyr)

# Calculate the ratio and summarize by project_sector
sector_ratios <- df_clean %>%
  # Exclude rows where project_cost is 0 or NA to avoid division errors
  filter(!is.na(project_cost) & project_cost > 0) %>%
  mutate(ratio = fixed_cost / project_cost) %>%  # Calculate the ratio
  group_by(project_sector) %>%  # Group by project_sector
  summarise(average_ratio = round(mean(ratio, na.rm = TRUE), 2), .groups = 'drop')  # Compute the average ratio

# Calculate the average ratio for all projects
all_projects_ratio <- df_clean %>%
  filter(!is.na(project_cost) & project_cost > 0) %>%
  mutate(ratio = fixed_cost / project_cost) %>%
  summarise(average_ratio = round(mean(ratio, na.rm = TRUE), 1)) %>%
  mutate(project_sector = "All projects")  # Add 'All projects' label

# Combine the sector-wise data with the 'All projects' row
sector_ratios_with_total <- bind_rows(sector_ratios, all_projects_ratio)

# Display the resulting data frame
print(sector_ratios_with_total)






# Filter projects where fixed_cost > project_cost and count by project_sector
sector_counts <- df_clean %>%
  filter(!is.na(project_cost) & project_cost > 0 & fixed_cost > project_cost) %>%
  group_by(project_sector) %>%
  summarise(count = n(), .groups = 'drop')  # Count the number of projects

# Display the resulting data frame
print(sector_counts)


# Filter out 'All Projects' from the data for plotting
sector_ratios_filtered <- sector_ratios_with_total %>%
  filter(project_sector != "All projects")

# Plot the data
plot_Int_4 <- ggplot(sector_ratios_filtered, aes(x = reorder(project_sector, average_ratio), y = average_ratio, fill = project_sector)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +  # Add horizontal line at y = 1
  geom_text(aes(label = average_ratio), vjust = -0.5, color = "black") +  # Add labels at the top of the bars
  coord_flip() +  # Flip coordinates to make the x-axis vertical for better readability
  labs(title = "Proportion of Fixed Cost to Project Cost",
       x = "Project Sector",
       y = "Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

print(plot_Int_4)
# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Int_Plots\\Plot_Int_4.png", 
       plot = plot_Int_4, width = 12, height = 10, dpi = 300)

```


 ##########################################################################################  
  

#Slide 8: Replace the stacked bar plot for mode of finance with two pie charts for fixed cost size, sectors. {Code}  

##Counts by mode of finance and general  
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}


df_clean$general <- ifelse(!is.na(df_clean$caste) & !is.na(df_clean$gender) & 
                           df_clean$caste == "General" & df_clean$gender == "Male", 1, 0)


library(dplyr)
library(tidyr)

# Ensure 'general' is treated as a factor
df_clean <- df_clean %>%
  mutate(general = factor(general, levels = c(1, 0), labels = c("General", "Special")))

# Prepare data frame with counts of 'mode_of_finance' for each 'general' category
data_summary <- df_clean %>%
  filter(!is.na(general) & !is.na(mode_of_finance)) %>%  # Exclude NA values
  group_by(general, mode_of_finance) %>%
  summarise(count = n(), .groups = 'drop') %>%
  # Calculate total count for each 'general' category
  group_by(general) %>%
  mutate(total = sum(count)) %>%
  # Calculate percentage
  mutate(percentage = round((count / total) * 100, 1)) %>%
  # Create a formatted string for counts and percentages
  mutate(label = paste0(count, " (", percentage, "%)")) %>%
  # Reshape to wide format
  pivot_wider(names_from = mode_of_finance, values_from = label, values_fill = "") %>%
  # Drop the total column as it's not needed in the final output
  select(-total) %>%
  arrange(general)  # Arrange the data by 'general' for better readability

# Display the resulting wide format data frame
print(data_summary)

```

  
##Counts by mode of finance, general and sectors
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(dplyr)
library(tidyr)

df_clean$general <- ifelse(!is.na(df_clean$caste) & !is.na(df_clean$gender) & 
                           df_clean$caste == "General" & df_clean$gender == "Male", 1, 0)

# Ensure 'general' is treated as a factor
df_clean <- df_clean %>%
  mutate(general = factor(general, levels = c(1, 0), labels = c("General", "Special")))

# Check if the necessary columns are present and have valid values
summary(df_clean)


# Check data_summary
data_summary <- df_clean %>%
  filter(!is.na(general) & !is.na(mode_of_finance) & !is.na(project_sector)) %>%
  group_by(general, mode_of_finance, project_sector) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(general, project_sector) %>%
  mutate(total = sum(count)) %>%
  mutate(percentage = round((count / total) * 100, 1)) %>%
  mutate(label = paste0(count, " (", percentage, "%)")) %>%
  pivot_wider(names_from = mode_of_finance, values_from = label, values_fill = "") %>%
  select(-total) %>%
  arrange(general, project_sector)

# Inspect the data
print(data_summary)



```
  

  
# Percentages for General and Special for:


##Data Frame (Mode of Finance)

Data Frame
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(dplyr)

# Create a summary data frame with counts and percentages for 'mode_of_finance' and 'general'
mode_of_finance_summary <- df_clean %>%
  filter(!is.na(mode_of_finance)) %>%  # Exclude NA values
  group_by(mode_of_finance, general) %>%  # Group by both 'mode_of_finance' and 'general'
  summarise(count = n(), .groups = 'drop') %>%
  # Calculate total count for each 'general' category
  group_by(general) %>%
  mutate(total = sum(count),
         percentage = round((count / total) * 100, 1)) %>%
  # Create label for counts and percentages
  mutate(label = paste0(count, " (", percentage, "%)")) %>%
  # Select the columns to include in the final data frame
  select(mode_of_finance, general, label) %>%
  # Arrange by mode_of_finance and general if needed
  arrange(general, mode_of_finance)

# Display the resulting data frame
print(mode_of_finance_summary)



```
Plot
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(ggplot2)
library(dplyr)

# Create a summary data frame with counts and percentages for 'mode_of_finance' and 'general'
mode_of_finance_summary <- df_clean %>%
  filter(!is.na(mode_of_finance)) %>%  # Exclude NA values
  group_by(mode_of_finance, general) %>%  # Group by both 'mode_of_finance' and 'general'
  summarise(count = n(), .groups = 'drop') %>%
  # Calculate total count for each 'general' category
  group_by(general) %>%
  mutate(total = sum(count),
         percentage = round((count / total) * 100, 1)) %>%
  # Create label for counts and percentages
  mutate(label = paste0(count, " (", percentage, "%)")) %>%
  # Select the columns to include in the final data frame
  select(mode_of_finance, general, count, label) %>%
  # Arrange by mode_of_finance and general if needed
  arrange(general, mode_of_finance)

# Display the resulting data frame to ensure correctness
print(mode_of_finance_summary)

# Define the file path and name
xl_modeoffinance <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\mode_of_finance.xlsx"

# Export the data frame to Excel
write_xlsx(mode_of_finance_summary, path = xl_modeoffinance)

# Create the plot with facet_wrap
plot_Int_5 <- ggplot(mode_of_finance_summary, aes(x = mode_of_finance, y = count, fill = mode_of_finance)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_text(aes(label = label), position = position_dodge(width = 0.8), vjust = -0.5) +
  labs(title = "Counts by Mode of Finance and General/Special Categories",
       x = "Mode of Finance",
       y = "Count",
       fill = "Mode of Finance") +
  theme_minimal() +
  theme(legend.position = "bottom", axis.text.x = element_text(angle = 0, hjust = 1)) +
  facet_wrap(~ general, labeller = as_labeller(c(`0` = "Special", `1` = "General")))

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Int_Plots\\Plot_Int_5.png", 
       plot = plot_Int_5, width = 12, height = 10, dpi = 300)


```






#Data Frame (Project Size)
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}

library(dplyr)
library(tidyr)

# Define fixed cost ranges
df_clean <- df_clean %>%
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 2500000, 5000000, 10000000, Inf),
                                labels = c("Below 25 lakhs", "25-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                right = FALSE))

# Summarize counts by fixed cost range and general category
summary_by_range <- df_clean %>%
  filter(!is.na(general) & !is.na(fixed_cost_range)) %>%
  group_by(fixed_cost_range, general) %>%
  summarise(count = n(), .groups = 'drop') %>%
  # Calculate total counts for each fixed cost range
  group_by(fixed_cost_range) %>%
  mutate(total = sum(count),
         percentage = round((count / total) * 100, 1)) %>%
  # Create labels for counts and percentages
  mutate(label = paste0(count, " (", percentage, "%)")) %>%
  # Pivot to wide format for counts and percentages
  pivot_wider(names_from = general, values_from = label, values_fill = "") %>%
  # Rename columns to match required format
  rename("General" = "General",
         "Special" = "Special") %>%
  # Select and rearrange columns to match the desired output
  select(fixed_cost_range, General, Special) %>%
  arrange(fixed_cost_range)

# Display the resulting data frame
print(summary_by_range)



```

  
#Data Frame (Project Sector)
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
 library(dplyr)
library(tidyr)

# Define project sector if needed; otherwise, use existing project_sector
# (Assuming 'project_sector' is already present and does not need transformation)

# Summarize counts by project sector and general category
summary_by_sector <- df_clean %>%
  filter(!is.na(general) & !is.na(project_sector)) %>%
  group_by(project_sector, general) %>%
  summarise(count = n(), .groups = 'drop') %>%
  # Calculate total counts for each project sector
  group_by(project_sector) %>%
  mutate(total = sum(count),
         percentage = round((count / total) * 100, 1)) %>%
  # Create labels for counts and percentages
  mutate(label = paste0(count, " (", percentage, "%)")) %>%
  # Pivot to wide format for counts and percentages
  pivot_wider(names_from = general, values_from = label, values_fill = "") %>%
  # Rename columns to match required format
  rename("General" = "General",
         "Special" = "Special") %>%
  # Select and rearrange columns to match the desired output
  select(project_sector, General, Special) %>%
  arrange(project_sector)

# Display the resulting data frame
print(summary_by_sector)
 

# Define the file path and name
xl_modeoffinance <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\mode_of_finance.xlsx"

# Export the data frame to Excel
write_xlsx(mode_of_finance_summary, path = xl_modeoffinance)
```

  
  
  
  

 
# Mode of Finance with Sectors
 
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Load necessary packages
library(dplyr)
library(tidyr)

# Create a summary data frame with counts and percentages for each combination of mode_of_finance and project_sector
summary_df <- df_clean %>%
  group_by(mode_of_finance, project_sector) %>%
  summarise(
    count = n(),
    percentage = round((n() / nrow(df_clean)) * 100, 1)  # Round percentage to one decimal place
  ) %>%
  arrange(project_sector, mode_of_finance)  # Arrange by project_sector for a better layout

# Pivot the data frame to a wide format
wide_format_df <- summary_df %>%
  pivot_wider(
    names_from = mode_of_finance,
    values_from = c(count, percentage),
    names_sep = "_",  # To distinguish between count and percentage columns
    values_fill = list(count = 0, percentage = 0)  # Fill missing values with 0
  )

# Arrange in descending order of the count for 'Bank Loan'
wide_format_df <- wide_format_df %>%
  arrange(desc(`count_Bank Loan`))  # Adjust the column name as necessary

# Print the wide format data frame
print(wide_format_df)

# Define the file path and name
xl_mof_sector <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\mof_sector.xlsx"

# Export the data frame to Excel
write_xlsx(wide_format_df, path = xl_mof_sector)

```
 
  
#Demographics 
  
```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Load necessary packages
library(dplyr)
library(tidyr)

# Create a summary data frame with counts and percentages for each combination of caste and gender
caste_gender_summary_df <- df_clean %>%
  group_by(caste, gender) %>%
  summarise(
    count = n(),
    percentage = round((n() / nrow(df_clean)) * 100, 1)  # Round percentage to one decimal place
  ) %>%
  # Pivot to wide format with separate columns for male and female
  pivot_wider(
    names_from = gender,
    values_from = c(count, percentage),
    names_sep = "_",  # To distinguish between count and percentage columns
    values_fill = list(count = 0, percentage = 0)  # Fill missing values with 0
  )

# Ensure the count columns are numeric
count_columns <- names(caste_gender_summary_df) %>%
  grep("^count_", ., value = TRUE)

# Convert count columns to numeric
caste_gender_summary_df <- caste_gender_summary_df %>%
  mutate(across(all_of(count_columns), as.numeric))


# Print the summary data frame
print(caste_gender_summary_df)



# Define the file path and name
xl_demo_caste <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\demo.xlsx"

# Export the data frame to Excel
write_xlsx(caste_gender_summary_df, path = xl_demo_caste)


```

#Comparing subsidy amount with half of fixed cost amount for special category
```{r, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, results='markup'}
df_clean_filtered <- df_clean_filtered %>%
  filter(general == "Special", !is.na(subsidy_amount)) %>%
  mutate(DPR_subsidy = fixed_cost / 2)

df_clean_filtered <- df_clean_filtered %>%
  mutate(inflated_subsidy = DPR_subsidy - subsidy_amount)



# Kernel Density Curve for inflated_subsidy
ggplot(df_clean_filtered, aes(x = inflated_subsidy)) +
  geom_density(fill = "lightblue", alpha = 0.6) +
  labs(
    title = "Kernel Density Plot for Inflated Subsidy",
    x = "Inflated Subsidy",
    y = "Density"
  ) +
  theme_minimal()



```
##Summary Stats

```{r, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, results='markup'}
# Separate data frames for negative and positive inflated_subsidy values
df_negative_inflated_subsidy <- df_clean_filtered %>%
  filter(inflated_subsidy < 0)

df_positive_inflated_subsidy <- df_clean_filtered %>%
  filter(inflated_subsidy > 0)


# Summary statistics for negative inflated_subsidy values
summary_stats_negative <- df_negative_inflated_subsidy %>%
  summarize(
    mean_inflated_subsidy = mean(inflated_subsidy, na.rm = TRUE),
    median_inflated_subsidy = median(inflated_subsidy, na.rm = TRUE),
    min_inflated_subsidy = min(inflated_subsidy, na.rm = TRUE),
    max_inflated_subsidy = max(inflated_subsidy, na.rm = TRUE),
    count = n(),
    na_count = sum(is.na(inflated_subsidy))
  )


# Summary statistics for positive inflated_subsidy values
summary_stats_positive <- df_positive_inflated_subsidy %>%
  summarize(
    mean_inflated_subsidy = mean(inflated_subsidy, na.rm = TRUE),
    median_inflated_subsidy = median(inflated_subsidy, na.rm = TRUE),
    min_inflated_subsidy = min(inflated_subsidy, na.rm = TRUE),
    max_inflated_subsidy = max(inflated_subsidy, na.rm = TRUE),
    count = n(),
    na_count = sum(is.na(inflated_subsidy))
  )


# View the summary stats for negative values
summary_stats_negative

# View the summary stats for positive values
summary_stats_positive

```

## Count of applicants in special category who received subsidy
```{r, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, results='markup'}
# Count observations where general == "Special" and subsidy_amount is not NA
count_special_subsidy <- df_clean_filtered %>%
  filter(general == "Special" & !is.na(subsidy_amount)) %>%
  count()

# View the count
count_special_subsidy

```


  
#----------------------------------------
 
#Profiling

#Share of sectors for all projects

Data Frame  
```{r, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, results='markup'}
# Load necessary package
library(dplyr)

# Count the number of projects and calculate percentages for each project sector
project_sector_summary <- df_clean %>%
  group_by(sectors) %>%
  summarise(
    count = n(),
    percentage = round((n() / nrow(df_clean)) * 100, 1)  # Round percentage to one decimal place
  ) %>%
  arrange(desc(count))

# Print the summary
print(project_sector_summary)

# Define the file path and name
xl_sector_share_all <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\sector_share_all.xlsx"

# Export the data frame to Excel
write_xlsx(project_sector_summary, path = xl_sector_share_all)


```

Plot
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Define custom colors for the sectors
sector_colors <- c(
      "Agriculture" = "green",  # Custom color for Agriculture Sector
      "Horticulture" = "orange",  # Custom color for Horticulture Sector
      "Fisheries" = "lightblue",     # Custom color for Fisheries Sector
      "Animal Husbandry and Veterinary" = "coral",         # Custom color for AH&VS Sector
      "Agri-Engineering" = "yellow",
      "Rest" = "grey"               # Custom color for Other
)

# Create the pie chart
pie_chart <- ggplot(project_sector_summary, aes(x = "", y = count, fill = sectors)) +
  geom_bar(stat = "identity", width = 1) +
  
  # Convert to pie chart
  coord_polar(theta = "y") +
  
  # Customization options
  labs(
    title = "Distribution of Projects by Sector",
    fill = "Sector"  # Legend title
  ) +
  
  # Customize the fill colors
  scale_fill_manual(values = sector_colors) +
  
  # Add labels to the pie chart
  geom_text(aes(label = paste0(sectors, "\n", round(100 * count / sum(count), 1), "%")),
            position = position_stack(vjust = 0.5), size = 4, color = "white") +
  
  # Customize the theme
  theme_minimal() +
  theme(
    axis.title.x = element_blank(),  # Remove x-axis title
    axis.title.y = element_blank(),  # Remove y-axis title
    axis.text = element_blank(),     # Remove axis text
    axis.ticks = element_blank(),    # Remove axis ticks
    plot.title = element_text(size = 16, face = "bold", hjust = 0.5),  # Customize plot title
    legend.text = element_text(size = 10),  # Customize legend text size
    legend.title = element_text(size = 12, face = "bold")  # Customize legend title
  )

# Display the pie chart
print(pie_chart)
```




# Making a factor variable for General Applicants (Applicants getting 40 per cent subsidy ~ General Male applicants)  
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Load necessary library
library(dplyr)

# Add a 'general' column to df_clean
df_clean_filtered <- df_clean_filtered %>%
  mutate(general = ifelse(!is.na(caste) & !is.na(gender) & 
                           caste == "General" & gender == "Male", 
                           "General", "Special"))

# Ensure 'general' is treated as a factor with descriptive labels
df_clean_filtered <- df_clean_filtered %>%
  mutate(general = factor(general, levels = c("General", "Special")))

# Create a table with counts
count_table <- table(df_clean_filtered$general)

# Convert the table to a data frame
count_df <- as.data.frame(count_table)

# Rename the columns for clarity
colnames(count_df) <- c("Category", "Count")

# Calculate the percentage
count_df$Percentage <- (count_df$Count / sum(count_df$Count)) * 100

# Display the final data frame
print(count_df)


```

 
  
#Number of Projects by Sector and subsidy category
  
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)

# Combine 'Inter-sectoral' and 'Intra-sectoral' into a single category
df_clean <- df_clean %>%
  mutate(project_sector = case_when(
    project_sector %in% c('Inter-sectoral', 'Intra-sectoral') ~ 'Combined Sectoral',
    TRUE ~ project_sector
  ))

# Summarize counts by project sector and general category
summary_by_sector <- df_clean %>%
  filter(!is.na(general) & !is.na(project_sector)) %>%
  group_by(project_sector, general) %>%
  summarise(count = n(), .groups = 'drop') %>%
  # Pivot to wide format for counts
  pivot_wider(names_from = general, values_from = count, values_fill = 0) %>%
  # Rename columns to match required format
  rename("General" = "General",
         "Special" = "Special") %>%
  # Select and rearrange columns to match the desired output
  select(project_sector, General, Special) %>%
  arrange(project_sector)

# Display the resulting data frame
print(summary_by_sector)


xl_1 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\sector_category.xlsx"

# Export the data frame to Excel
write_xlsx(summary_by_sector, path = xl_1)

```
  
  
#Projects above 1 crore by sector
```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(writexl)

# Filter projects with fixed_cost above 1 crore and group by project_sector and project_type
projects_above_1_crore <- df_clean %>%
  filter(fixed_cost > 10000000) %>%
  group_by(project_sector, project_type) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(desc(count))  # Arrange in descending order by count

# Calculate the total count of projects for each sector
sector_totals <- projects_above_1_crore %>%
  group_by(project_sector) %>%
  summarise(count = sum(count), project_type = "Total", .groups = 'drop')

# Calculate the grand total across all sectors and types
grand_total <- projects_above_1_crore %>%
  summarise(count = sum(count), project_sector = "Total", project_type = "Total")

# Combine the original data frame with sector totals and grand total
projects_above_1_crore_with_totals <- bind_rows(projects_above_1_crore, sector_totals, grand_total)

# Display the updated summary data frame
print(projects_above_1_crore_with_totals)

# Define the path for the Excel file
xl_2 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\sector_above1crore.xlsx"

# Export the data frame to Excel
write_xlsx(projects_above_1_crore_with_totals, path = xl_2)




```

#Frequency of projects above 1 crore 
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(dplyr)

# Define the ranges for the fixed cost bins (crores)
fixed_cost_bins <- seq(1e7, max(df_clean_filtered$fixed_cost, na.rm = TRUE), by = 1e7)  # Steps of 1 crore

# Filter projects with fixed_cost above 1 crore and categorize into ranges
projects_above_1_crore <- df_clean_filtered %>%
  filter(fixed_cost > 1e7) %>%
  mutate(fixed_cost_range = cut(fixed_cost, 
                                breaks = fixed_cost_bins, 
                                labels = paste(seq(1, length(fixed_cost_bins) - 1), 
                                               seq(2, length(fixed_cost_bins)), 
                                               sep = "-"), 
                                include.lowest = TRUE, 
                                right = FALSE))

# Create the frequency table
frequency_table <- projects_above_1_crore %>%
  group_by(fixed_cost_range) %>%
  summarize(total_projects = n()) %>%
  arrange(fixed_cost_range)

# Print the frequency table
print(frequency_table)


```

 
#Mode of Finance for all projects by size
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(tidyr)

# Calculate the count for each fixed cost range and mode_of_finance
range_mode_of_finance_counts <- df_clean_filtered %>%
  group_by(project_cost_range, mode_of_finance) %>%
  summarize(mode_count = n(), .groups = 'drop')

# Pivot the data to wide format with 'Bank' and 'Self' as columns
final_frame <- range_mode_of_finance_counts %>%
  pivot_wider(names_from = mode_of_finance, values_from = mode_count, values_fill = 0)

# Check the column names to see the exact names created
print(colnames(final_frame))

# Now you can select the correct columns based on the names in your data
# Replace 'Bank' and 'Self' with the actual column names if they differ
final_frame <- final_frame %>%
  select(project_cost_range, `Bank Loan`, `Self`)  # Use backticks if the column names have special characters

# Display the final data frame
print(final_frame)



xl_3 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\mof_all_fixed_size.xlsx"

# Export the data frame to Excel
write_xlsx(final_frame, path = xl_3)

```
  
  
```{r}
library(dplyr)
library(tidyr)

# Calculate the count for each fixed cost range and mode_of_finance
range_mode_of_finance_counts <- df_clean_filtered %>%
  group_by(project_cost_range, mode_of_finance) %>%
  summarize(mode_count = n(), .groups = 'drop')

# Pivot the data to wide format with 'Bank' and 'Self' as columns
final_frame <- range_mode_of_finance_counts %>%
  pivot_wider(names_from = mode_of_finance, values_from = mode_count, values_fill = 0)

# Check the column names to see the exact names created
print(colnames(final_frame))

# Now you can select the correct columns based on the names in your data
# Replace 'Bank' and 'Self' with the actual column names if they differ
final_frame <- final_frame %>%
  select(fixed_cost_range, `Bank Loan`, `Self`)  # Use backticks if the column names have special characters

# Display the final data frame
print(final_frame)


```
  
  
#Mode of finance for all projects by caste 
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(dplyr)

# Summarize the data to get the count of projects by caste and mode_of_finance
df_caste_finance_summary <- df_clean %>%
  group_by(caste, mode_of_finance) %>%
  summarise(count = n(), .groups = 'drop')  # Count the number of projects and drop grouping after summarizing

# Display the resulting data frame
print(df_caste_finance_summary)

xl_4 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\mof_all_caste.xlsx"

# Export the data frame to Excel
write_xlsx(df_caste_finance_summary, path = xl_4)
```
 
 
  
#Kernel distributions for fixed to project cost by fixed cost ranges (4 ranges)
```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)
library(gridExtra)

# Filter out rows with NA values in fixed_cost or project_cost
df_clean <- df_clean %>%
  filter(!is.na(fixed_cost) & !is.na(project_cost)) %>%
  # Create fixed_cost_range categories
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 2500000, 5000000, 10000000, Inf),
                                labels = c("Below 25 lakhs", "25-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                right = FALSE))

# Calculate the ratio of fixed_cost to project_cost
df_clean_filtered <- df_clean %>%
  mutate(ratio = fixed_cost / project_cost)

# Create separate plots for each fixed_cost_range
plots <- df_clean_filtered %>%
  split(.$fixed_cost_range) %>%
  lapply(function(df) {
    ggplot(df, aes(x = ratio, fill = fixed_cost_range)) +
      geom_density(alpha = 0.5) +
      xlim(0, 3) +  # Limit x-axis to 3
      labs(title = paste("Kernel Density Plot for", unique(df$fixed_cost_range)),
           x = "Ratio of Fixed Cost to Project Cost",
           y = "Density") +
      theme_minimal()
  })

# Print each plot separately
for (plot in plots) {
  print(plot)
}



```

#Kernel distributions for fixed to project cost by fixed cost ranges (3 ranges) 
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)

# Filter out rows with NA values in fixed_cost or project_cost
df_clean <- df_clean %>%
  filter(!is.na(fixed_cost) & !is.na(project_cost)) %>%
  # Create fixed_cost_range categories including the new range
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 5000000, 10000000, Inf),
                                labels = c("0-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                right = FALSE))

# Calculate the ratio of fixed_cost to project_cost
df_clean_filtered <- df_clean %>%
  mutate(ratio = fixed_cost / project_cost)

# Create separate plots for each fixed_cost_range
plots <- df_clean_filtered %>%
  split(.$fixed_cost_range) %>%
  lapply(function(df) {
    ggplot(df, aes(x = ratio, fill = fixed_cost_range)) +
      geom_density(alpha = 0.5) +
      xlim(0, 3) +  # Limit x-axis to 3
      labs(title = paste("Kernel Density Plot for", unique(df$fixed_cost_range)),
           x = "Ratio of Fixed Cost to Project Cost",
           y = "Density") +
      theme_minimal()
  })

# Print each plot separately
for (plot in plots) {
  print(plot)
}

```
 
 
  
  
#Kernel distributions for fixed to project cost by project sectors 
```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)

# Combine 'Inter-Sectoral Department' and 'Intra-Sectoral Department' into 'Rest'
df_clean_combined <- df_clean %>%
  mutate(
    project_sector = case_when(
      project_sector %in% c('Inter-Sectoral Department', 'Intra-Sectoral Department') ~ 'Rest',
      TRUE ~ project_sector
    )
  )

# Filter out rows with NA values in fixed_cost or project_cost
df_filtered <- df_clean_combined %>%
  filter(!is.na(fixed_cost) & !is.na(project_cost))

# Calculate the ratio of fixed_cost to project_cost
df_filtered <- df_filtered %>%
  mutate(ratio = fixed_cost / project_cost)

# Create separate plots for each project_sector
plots <- df_filtered %>%
  split(.$project_sector) %>%
  lapply(function(df) {
    ggplot(df, aes(x = ratio, fill = project_sector)) +
      geom_density(alpha = 0.5) +
      xlim(0, 3) +  # Limit x-axis to 3
      labs(title = paste("Kernel Density Plot for", unique(df$project_sector)),
           x = "Ratio of Fixed Cost to Project Cost",
           y = "Density") +
      theme_minimal()
  })

# Print each plot separately
for (plot in plots) {
  print(plot)
}



```
 
  
#Ratio of fixed cost to project cost by sectors (mean)

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)

# Calculate the ratio and summarize by project_sector
sector_ratios <- df_clean %>%
  # Exclude rows where project_cost is 0 or NA to avoid division errors
  filter(!is.na(project_cost) & project_cost > 0) %>%
  mutate(ratio = fixed_cost / project_cost) %>%  # Calculate the ratio
  group_by(project_sector) %>%  # Group by project_sector
  summarise(average_ratio = round(mean(ratio, na.rm = TRUE), 2), .groups = 'drop')  # Compute the average ratio

# Calculate the average ratio for all projects
all_projects_ratio <- df_clean %>%
  filter(!is.na(project_cost) & project_cost > 0) %>%
  mutate(ratio = fixed_cost / project_cost) %>%
  summarise(average_ratio = round(mean(ratio, na.rm = TRUE), 1)) %>%
  mutate(project_sector = "All projects")  # Add 'All projects' label

# Combine the sector-wise data with the 'All projects' row
sector_ratios_with_total <- bind_rows(sector_ratios, all_projects_ratio)

# Display the resulting data frame
print(sector_ratios_with_total)






# Filter projects where fixed_cost > project_cost and count by project_sector
sector_counts <- df_clean %>%
  filter(!is.na(project_cost) & project_cost > 0 & fixed_cost > project_cost) %>%
  group_by(project_sector) %>%
  summarise(count = n(), .groups = 'drop')  # Count the number of projects

# Display the resulting data frame
print(sector_counts)


# Filter out 'All Projects' from the data for plotting
sector_ratios_filtered <- sector_ratios_with_total %>%
  filter(project_sector != "All projects")

# Plot the data
plot_Int_4 <- ggplot(sector_ratios_filtered, aes(x = reorder(project_sector, average_ratio), y = average_ratio, fill = project_sector)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +  # Add horizontal line at y = 1
  geom_text(aes(label = average_ratio), vjust = -0.5, color = "black") +  # Add labels at the top of the bars
  coord_flip() +  # Flip coordinates to make the x-axis vertical for better readability
  labs(title = "Proportion of Fixed Cost to Project Cost",
       x = "Project Sector",
       y = "Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

plot(plot_Int_4)
```






#Ratio of fixed cost to project cost by sectors (median)
  
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)

# Combine 'Inter-Sectoral Department' and 'Intra-Sectoral Department' into 'Rest'
df_clean_combined <- df_clean %>%
  mutate(
    project_sector = case_when(
      project_sector %in% c('Inter-Sectoral Department', 'Intra-Sectoral Department') ~ 'Rest',
      TRUE ~ project_sector
    )
  )

# Calculate the ratio and summarize by project_sector with median
sector_ratios <- df_clean_combined %>%
  # Exclude rows where project_cost is 0 or NA to avoid division errors
  filter(!is.na(project_cost) & project_cost > 0) %>%
  mutate(ratio = fixed_cost / project_cost) %>%  # Calculate the ratio
  group_by(project_sector) %>%  # Group by project_sector
  summarise(median_ratio = round(median(ratio, na.rm = TRUE), 2), .groups = 'drop')  # Compute the median ratio

# Calculate the median ratio for all projects
all_projects_ratio <- df_clean_combined %>%
  filter(!is.na(project_cost) & project_cost > 0) %>%
  mutate(ratio = fixed_cost / project_cost) %>%
  summarise(median_ratio = round(median(ratio, na.rm = TRUE), 2)) %>%
  mutate(project_sector = "All projects")  # Add 'All projects' label

# Combine the sector-wise data with the 'All projects' row
sector_ratios_with_total <- bind_rows(sector_ratios, all_projects_ratio)

# Display the resulting data frame
print(sector_ratios_with_total)


xl_4 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\sector_ratios.xlsx"

# Export the data frame to Excel
write_xlsx(sector_ratios_with_total, path = xl_4)


# Filter projects where fixed_cost > project_cost and count by project_sector
sector_counts <- df_clean_combined %>%
  filter(!is.na(project_cost) & project_cost > 0 & fixed_cost > project_cost) %>%
  group_by(project_sector) %>%
  summarise(count = n(), .groups = 'drop')  # Count the number of projects

# Display the resulting data frame
print(sector_counts)

# Filter out 'All Projects' from the data for plotting
sector_ratios_filtered <- sector_ratios_with_total %>%
  filter(project_sector != "All projects")

# Plot the data
plot_Int_4 <- ggplot(sector_ratios_filtered, aes(x = reorder(project_sector, median_ratio), y = median_ratio, fill = project_sector)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +  # Add horizontal line at y = 1
  geom_text(aes(label = median_ratio), vjust = -0.5, color = "black") +  # Add labels at the top of the bars
  coord_flip() +  # Flip coordinates to make the x-axis vertical for better readability
  labs(title = "Proportion of Fixed Cost to Project Cost (Median)",
       x = "Project Sector",
       y = "Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

print(plot_Int_4)


```
#Ratio of fixed cost to project cost by size (median)
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Create 'fixed_cost_range' using the specified breaks and labels, and exclude NA values
df_clean_combined <- df_clean %>%
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 2500000, 5000000, 10000000, Inf),
                                labels = c("Below 25 lakhs", "25-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                right = FALSE))


# Calculate the ratio and summarize by fixed_cost_range with median
cost_range_ratios <- df_clean_combined %>%
  # Exclude rows where project_cost is 0 or NA to avoid division errors
  filter(!is.na(project_cost) & project_cost > 0) %>%
  mutate(ratio = fixed_cost / project_cost) %>%  # Calculate the ratio
  group_by(fixed_cost_range) %>%  # Group by fixed_cost_range
  summarise(median_ratio = round(median(ratio, na.rm = TRUE), 2), .groups = 'drop')  # Compute the median ratio

# Calculate the median ratio for all projects
all_projects_ratio <- df_clean_combined %>%
  filter(!is.na(project_cost) & project_cost > 0) %>%
  mutate(ratio = fixed_cost / project_cost) %>%
  summarise(median_ratio = round(median(ratio, na.rm = TRUE), 2)) %>%
  mutate(fixed_cost_range = "All projects")  # Add 'All projects' label

# Combine the cost-range-wise data with the 'All projects' row
cost_range_ratios_with_total <- bind_rows(cost_range_ratios, all_projects_ratio)

# Display the resulting data frame
print(cost_range_ratios_with_total)

```
  
  
  
  
#Observations for which Project cost < Fixed Cost
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)

# Filter out rows with NA values in fixed_cost or project_cost
df_clean <- df_clean %>%
  filter(!is.na(fixed_cost) & !is.na(project_cost)) %>%
  # Create fixed_cost_range categories
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 2500000, 5000000, 10000000, Inf),
                                labels = c("Below 25 lakhs", "25-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                right = FALSE))

# Count the number of observations where fixed_cost is more than project_cost by fixed_cost_range
count_by_range <- df_clean %>%
  filter(fixed_cost > project_cost) %>%  # Filter where fixed_cost is greater than project_cost
  group_by(fixed_cost_range) %>%         # Group by fixed_cost_range
  summarise(count = n(), .groups = 'drop')  # Count the number of observations

# Display the result
print(count_by_range)






# Filter out rows with NA values in fixed_cost or project_cost
df_clean <- df_clean %>%
  filter(!is.na(fixed_cost) & !is.na(project_cost)) %>%
  # Create fixed_cost_range categories
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 2500000, 5000000, 10000000, Inf),
                                labels = c("Below 25 lakhs", "25-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                right = FALSE))

# Count the number of observations where fixed_cost is more than project_cost by project_sector
count_by_sector <- df_clean %>%
  filter(fixed_cost > project_cost) %>%  # Filter where fixed_cost is greater than project_cost
  group_by(project_sector) %>%          # Group by project_sector
  summarise(count = n(), .groups = 'drop')  # Count the number of observations

# Display the result
print(count_by_sector)







# Filter out rows with NA values in fixed_cost or project_cost
df_clean <- df_clean %>%
  filter(!is.na(fixed_cost) & !is.na(project_cost))

# Create a new data frame with only the specified columns where fixed_cost is greater than project_cost
filtered_data <- df_clean %>%
  filter(fixed_cost > project_cost) %>%  # Filter rows where fixed_cost is greater than project_cost
  select(project_cost, fixed_cost, project_sector, project_type, registration_date) %>%  # Select relevant columns
  mutate(difference = fixed_cost - project_cost)  # Add a column for the difference

# Calculate the mean of the difference column
mean_difference <- filtered_data %>%
  summarise(mean_diff = mean(difference, na.rm = TRUE))

# Print the new data frame and the mean difference
print(filtered_data)
print(mean_difference)


```

  
  
#Unpacking the 'Special' Category to look at SC, ST and OBC separately
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Create a new variable 'caste_group' that recategorizes the levels
df_clean_filtered <- df_clean_filtered %>%
  mutate(caste_group = case_when(
    caste %in% c("General", "OBC", "SC", "ST") ~ caste,  # Keep these categories as they are
    caste %in% c("Agri Allied", "Other", "PWD") ~ "Rest",  # Combine these into 'Rest'
    TRUE ~ NA_character_  # If there's an unexpected level, mark it as NA (optional)
  ))
```
  
  
##Data frame for number of projects by size for the new caste categories
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Summarize the data by fixed_cost_range and caste_group
project_summary <- df_clean_filtered %>%
  filter(general == "Special") %>%  # Filter for cases where general is "Special"
  group_by(fixed_cost_range, caste_group) %>%
  summarise(count = n(), .groups = 'drop')  # Count the number of projects

# Calculate the total number of projects per caste_group
total_projects_by_caste <- project_summary %>%
  group_by(caste_group) %>%
  summarise(total_count = sum(count))

# Merge the total count back into the original summary
project_summary <- project_summary %>%
  left_join(total_projects_by_caste, by = "caste_group")

# Calculate percentage by fixed_cost_range within each caste_group
project_summary <- project_summary %>%
  mutate(percentage = (count / total_count) * 100)

# Create a new column that combines count and percentage in the format "count (xx%)"
project_summary <- project_summary %>%
  mutate(count_with_percentage = paste0(count, " (", round(percentage, 1), "%)"))

# Pivot the data to wide format using the new combined count and percentage column
project_summary_wide <- project_summary %>%
  select(fixed_cost_range, caste_group, count_with_percentage) %>%
  pivot_wider(names_from = fixed_cost_range, values_from = count_with_percentage, values_fill = "0 (0%)")

# Display the resulting wide format data frame
print(project_summary_wide)





xl_5 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\special_1.xlsx"

# Export the data frame to Excel
write_xlsx(project_summary_wide, path = xl_5)
```
 
##Data frame for number of projects by mode of finance for the new caste categories 

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Summarize the data by caste_group and mode_of_finance
project_summary_mode_of_finance <- df_clean_filtered %>%
  filter(general == "Special") %>%  # Filter for cases where general is "Special"
  group_by(mode_of_finance, caste_group) %>%
  summarise(count = n(), .groups = 'drop')  # Count the number of projects

# Pivot the data to wide format
project_summary_wide_mode_of_finance <- project_summary_mode_of_finance %>%
  pivot_wider(names_from = caste_group, values_from = count, values_fill = 0)  # Fill missing values with 0

# Display the resulting wide format data frame
print(project_summary_wide_mode_of_finance)

xl_6 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\special_2.xlsx"

# Export the data frame to Excel
write_xlsx(project_summary_wide_mode_of_finance, path = xl_6)
```
  

##Data frame for number of projects by project sectors for the new caste categories
  
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Summarize the data by caste_group and project_sector
project_summary_sector <- df_clean_filtered %>%
  filter(general == "Special") %>%  # Filter for cases where general is "Special"
  group_by(sectors, caste_group) %>%
  summarise(count = n(), .groups = 'drop')  # Count the number of projects

# Pivot the data to wide format
project_summary_wide_sector <- project_summary_sector %>%
  pivot_wider(names_from = caste_group, values_from = count, values_fill = 0)  # Fill missing values with 0

# Display the resulting wide format data frame
print(project_summary_wide_sector)

xl_7 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\special_3.xlsx"

# Export the data frame to Excel
write_xlsx(project_summary_wide_sector, path = xl_7)
```

 
#Plot 22: Map for spatial distribution of projects above 1 crore

Data frame
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}

# Filter projects with fixed_cost above 1 crore
projects_above_1_crore <- df_clean %>%
  filter(fixed_cost >= 10000000) %>%
  group_by(district) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(desc(count))  # Arrange in descending order by count

# Calculate the total count of projects
total_count <- projects_above_1_crore %>%
  summarise(count = sum(count)) %>%
  mutate(district = "Total")

# Combine the original data frame with the total row
projects_above_1_crore_with_total <- bind_rows(projects_above_1_crore, total_count)

# Display the updated summary data frame
print(projects_above_1_crore_with_total)

```

 Join
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(sf)
library(stringdist)

# Read the shapefile
odisha_districts <- st_read("C:\\Users\\Admin\\Documents\\CRFM\\Maps\\OD_district_shp_2\\odisha_district.shp")

# Standardize 'district' names in projects_above_1_crore to match odisha_districts format
projects_above_1_crore <- projects_above_1_crore %>%
  mutate(district = tools::toTitleCase(tolower(trimws(district))))

# Standardize 'district' names in odisha_districts to match the format
odisha_districts <- odisha_districts %>%
  mutate(district = tools::toTitleCase(tolower(trimws(district))))

# Manually update district names in odisha_districts
odisha_districts <- odisha_districts %>%
  mutate(district = case_when(
    district == "Baleshwar" ~ "Balasore",
    district == "Kendujhar" ~ "Keonjhar",
    district == "Subarnapur" ~ "Sonepur",
    district == "Anugul" ~ "Angul",
    district == "Khordha" ~ "Khurdha",
    district == "Nabarangapur" ~ "Nabarangpur",
    district == "Jajapur" ~ "Jajpur",
    district == "Bauda" ~ "Boudh",
    district == "Debagarh" ~ "Deogarh",
    # Add more manual updates if needed
    TRUE ~ district  # Keep other names unchanged
  ))




project_count <- projects_above_1_crore %>%
  group_by(district) %>%
  summarise(count = n(), .groups = 'drop')

# Join odisha_districts with the summarized project count
# No need to include geometry twice, so select geometry only from odisha_districts
final_data <- odisha_districts %>%
  left_join(projects_above_1_crore, by = "district")

projects_above_1_crore <- projects_above_1_crore %>%
  replace_na(list(count = 0))

# Inspect final_data
print(final_data)





# If needed, you can check if any districts from project_count didn't match
unmatched_districts <- project_count %>%
  filter(!district %in% final_data$district)

print(unmatched_districts)  # This will show if any district names need further standardization




```

Map
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(ggplot2)
library(viridis)  # For color scales

# Plot the map
plot_22 <- ggplot(data = final_data) +
  geom_sf(aes(fill = count), color = "black") +  # Fill based on 'count' with black boundaries
  scale_fill_gradient(low = "lightyellow", high = "red", name = "Application Count") +  # Red color scale
  geom_sf_text(aes(label = district), size = 5, color = "black", fontface = "bold") +  # Add district labels
  theme_minimal() +  # Clean theme
  labs(title = "", 
       caption = "") +  # Labels
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 10),
    plot.caption = element_text(size = 10),
    legend.title = element_text(size = 18),
    legend.text = element_text(size = 16),
    legend.key.size = unit(1.5, "cm"),  # Increase the size of the legend key
    axis.text.x = element_blank(),  # Remove x-axis text
    axis.text.y = element_blank(),  # Remove y-axis text
    axis.title.x = element_blank(),  # Remove x-axis title
    axis.title.y = element_blank(),  # Remove y-axis title
    legend.position = "bottom"  # Move legend to the bottom
  )

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_22.png", 
       plot = plot_22, width = 12, height = 10, dpi = 300)

print(plot_22)
```

#Number of Projects by size of the projects (General and Special category)
  
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)

# Sample data
# summary_df <- ... (Load or define your data frame here)

# Convert the counts (with percentages) back to numeric for plotting
summary_df$Special_count <- as.numeric(gsub(" \\(.*\\)", "", summary_df$Special))
summary_df$General_count <- as.numeric(gsub(" \\(.*\\)", "", summary_df$General))

# Reshape the data for easier plotting with faceting
plot_df <- summary_df %>%
  select(fixed_cost_range, Special_count, General_count) %>%
  pivot_longer(cols = c(Special_count, General_count),
               names_to = "Category",
               values_to = "Count") %>%
  mutate(Category = recode(Category, "Special_count" = "Special", "General_count" = "General"))

# Calculate total counts for each category
total_counts_by_category <- plot_df %>%
  group_by(Category) %>%
  summarize(Total = sum(Count, na.rm = TRUE))

# Merge total counts into the plot data
plot_df <- plot_df %>%
  left_join(total_counts_by_category, by = "Category") %>%
  mutate(Percentage = (Count / Total) * 100) %>%
  mutate(Percentage = round(Percentage)) %>%  # Round percentages to the nearest integer
  mutate(Label = paste0(Count, " (", Percentage, "%)"))

# Create the bar plots with a common y-axis using facet_wrap
plot_Int_1 <- ggplot(plot_df, aes(x = fixed_cost_range, y = Count, fill = fixed_cost_range)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Label), vjust = -0.5) +  # Use the Label column with rounded percentages
  labs(title = "Number of Projects by Fixed Cost Ranges",
       x = "Fixed Cost Ranges",
       y = "Count of Projects") +
  theme_minimal() +
  theme(legend.position = "none") +  # Hide legend since it's redundant
  facet_wrap(~ Category)  # Separate plots for Special and General

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Int_Plots\\Plot_Int_1.png", 
       plot = plot_Int_1, width = 12, height = 10, dpi = 300)

```
 

#List and count of banks 
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}

# Group by bank_name, exclude NA values, and count occurrences
bank_name_counts <- df_clean_filtered %>%
  filter(!is.na(bank_name)) %>%          # Exclude NA values
  group_by(bank_name) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count / sum(count)) * 100) %>%  # Calculate percentage share
  arrange(desc(count))  # Arrange by count in descending order

# Display the resulting data frame
print(bank_name_counts)


```

#List of project types
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
unique(df_clean_filtered$project_type)
```


  
#---------------------------------------------------
  
#Process 

#Count of Projects in the Registration Stage exceeding 200, 300, 400, 500 and 600 days

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count the number of observations exceeding 200 days and 300 days separately
count_exceeding_days <- df_clean %>%
  filter(!is.na(days_reg_goahead)) %>%  # Exclude NA values
  summarise(
    exceeding_100_days = sum(days_reg_goahead > 100),
    exceeding_200_days = sum(days_reg_goahead > 200),
    exceeding_300_days = sum(days_reg_goahead > 300),
    exceeding_400_days = sum(days_reg_goahead > 400),
    exceeding_500_days = sum(days_reg_goahead > 500),
    exceeding_600_days = sum(days_reg_goahead > 600)
  )

# Display the resulting data frame
print(count_exceeding_days)

```

#Data frame for sub stages

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Define the variables of interest
days_vars <- c("days_reg_blo", "days_blo_dno", "days_dno_collector",
               "days_collector_apicoldm", "days_apicoldm_goahead", 
               "days_goahead_sanction", "days_sanction_complete",
               "days_complete_blo_inspect", "days_blo_inspect_dno_comp", 
               "days_dno_comp_admin", "days_admin_src", "days_src_subsidy", "days_admin_subsidy")

# Create an empty data frame to store the results
summary_stats_final <- data.frame(
  vars = character(),
  median = numeric(),
  min = numeric(),
  max = numeric(),
  stringsAsFactors = FALSE
)

# Loop over each variable to filter negatives and calculate summary statistics
for (var in days_vars) {
  # Filter out negative values
  filtered_data <- df_clean[[var]][df_clean[[var]] >= 0]
  
  # Calculate summary statistics if there's data left after filtering
  if (length(filtered_data) > 0) {
    median_val <- round(median(filtered_data, na.rm = TRUE))
    min_val <- round(min(filtered_data, na.rm = TRUE))
    max_val <- round(max(filtered_data, na.rm = TRUE))
    
    # Append the results to the final data frame
    summary_stats_final <- rbind(summary_stats_final, 
                                 data.frame(vars = var, 
                                            median = median_val, 
                                            min = min_val, 
                                            max = max_val))
  }
}

# Display the resulting data frame
print(summary_stats_final)

xl_8 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\Plot_14.xlsx"

# Export the data frame to Excel
write_xlsx(summary_stats_final, path = xl_8)
```

##...by mode of finance
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Define the variables of interest
days_vars <- c("days_reg_blo", "days_blo_dno", "days_dno_collector",
               "days_collector_apicoldm", "days_apicoldm_goahead", 
               "days_goahead_sanction", "days_sanction_complete",
               "days_complete_blo_inspect", "days_blo_inspect_dno_comp", 
               "days_dno_comp_admin", "days_admin_src", "days_src_subsidy", "days_admin_subsidy")

# Initialize empty data frames to store the results for bank and self
summary_stats_bank <- data.frame(
  vars = character(),
  median = numeric(),
  min = numeric(),
  max = numeric(),
  stringsAsFactors = FALSE
)

summary_stats_self <- data.frame(
  vars = character(),
  median = numeric(),
  min = numeric(),
  max = numeric(),
  stringsAsFactors = FALSE
)

# Function to calculate summary stats based on mode_of_finance and treat negative values as NA
calculate_summary_stats <- function(df_clean_filtered, mode_of_finance_filter) {
  summary_stats <- data.frame(
    vars = character(),
    median = numeric(),
    min = numeric(),
    max = numeric(),
    stringsAsFactors = FALSE
  )
  
  for (var in days_vars) {
    # Replace negative values with NA
    filtered_data <- df_clean_filtered[[var]][df_clean_filtered$mode_of_finance == mode_of_finance_filter]
    filtered_data <- ifelse(filtered_data < 0, NA, filtered_data)
    
    if (length(filtered_data) > 0) {
      median_val <- round(median(filtered_data, na.rm = TRUE))
      min_val <- round(min(filtered_data, na.rm = TRUE))
      max_val <- round(max(filtered_data, na.rm = TRUE))
      
      # Append the results to the corresponding summary data frame
      summary_stats <- rbind(summary_stats, 
                             data.frame(vars = var, 
                                        median = median_val, 
                                        min = min_val, 
                                        max = max_val))
    }
  }
  
  return(summary_stats)
}

# Calculate summary statistics for bank
summary_stats_bank <- calculate_summary_stats(df_clean_filtered, "Bank Loan")

# Calculate summary statistics for self
summary_stats_self <- calculate_summary_stats(df_clean_filtered, "Self")

# Display the resulting data frames
print("Summary Statistics for Bank:")
print(summary_stats_bank)

print("Summary Statistics for Self:")
print(summary_stats_self)

# Specify the path to save the Excel file
xlx <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\sub_stagesbymof.xlsx"

# Create a named list of the data frames to write to separate sheets
data_frames_list <- list(
  "Bank" = summary_stats_bank,
  "Self" = summary_stats_self
)

# Export to Excel (adjust the write_xlsx function accordingly)
write_xlsx(data_frames_list, path = xlx)


```


#Data frame for days between major stages by project size
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Define fixed cost ranges
df_clean$fixed_cost_range <- cut(df_clean$fixed_cost,
                                   breaks = c(0, 2500000, 5000000, 10000000, Inf),
                                   labels = c("Below 25 lakhs", "25-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                   right = FALSE)

# Define the time difference variables
time_diff_vars <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", 
                    "days_src_subsidy")

# Create an empty data frame to store the results
summary_stats_fixed_cost <- data.frame(
  fixed_cost_range = character(),
  Stage = character(),
  median = numeric(),
  min = numeric(),
  max = numeric(),
  stringsAsFactors = FALSE
)

# Loop over each fixed cost range and calculate summary statistics
for (range in levels(df_clean$fixed_cost_range)) {
  
  # Filter the data for the current fixed cost range
  filtered_df <- df_clean %>%
    filter(fixed_cost_range == range) %>%
    mutate(across(all_of(time_diff_vars), ~ ifelse(. < 0, NA, .)))
  
  # Gather data for processing
  plot_data <- filtered_df %>%
    select(all_of(time_diff_vars)) %>%
    pivot_longer(everything(), names_to = "Stage", values_to = "Days") %>%
    filter(!is.na(Days))
  
  # Set factor levels for Stage to match the order of time_diff_vars
  plot_data$Stage <- factor(plot_data$Stage, levels = time_diff_vars)
  
  # Calculate summary statistics
  summary_points <- plot_data %>%
    group_by(Stage) %>%
    summarize(
      median = round(median(Days, na.rm = TRUE)),
      min = round(min(Days, na.rm = TRUE)),
      max = round(max(Days, na.rm = TRUE))
    ) %>%
    ungroup() %>%
    mutate(fixed_cost_range = range)  # Add the fixed cost range to the summary
  
  # Append the results to the final data frame
  summary_stats_fixed_cost <- rbind(summary_stats_fixed_cost, summary_points)
}

# Reorder columns to match the desired output format
summary_stats_fixed_cost <- summary_stats_fixed_cost %>%
  select(fixed_cost_range, Stage, median, min, max)

# Display the resulting data frame
print(summary_stats_fixed_cost)


xl_9 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\Plot_20.xlsx"

# Export the data frame to Excel
write_xlsx(summary_stats_fixed_cost, path = xl_9)
```

  
#Data frame for major stages by category (General and Special)  
  
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Define the time difference variables
time_diff_vars <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", 
                    "days_src_subsidy")

# Create a data frame to store the results based on the 'general' variable
summary_stats_general <- data.frame(
  general = character(),
  Stage = character(),
  median = numeric(),
  min = numeric(),
  max = numeric(),
  stringsAsFactors = FALSE
)

# Check unique values in 'general'
unique_general_values <- unique(df_clean$general)
print(paste("Unique values in 'general':", unique(unique_general_values)))

# Loop over each unique value in the 'general' variable and calculate summary statistics
for (group in unique_general_values) {
  cat("Processing group:", group, "\n")  # Debugging line

  # Filter the data for the current 'general' value
  filtered_df <- df_clean %>%
    filter(general == group) %>%
    mutate(across(all_of(time_diff_vars), ~ ifelse(. < 0, NA, .)))
  
  # Check if filtered data is empty
  if (nrow(filtered_df) == 0) {
    cat("No data for group:", group, "\n")  # Debugging line
    next
  }

  # Gather data for processing
  plot_data <- filtered_df %>%
    select(all_of(time_diff_vars)) %>%
    pivot_longer(everything(), names_to = "Stage", values_to = "Days") %>%
    filter(!is.na(Days))
  
  # Check if plot_data is empty
  if (nrow(plot_data) == 0) {
    cat("No valid data for group:", group, "\n")  # Debugging line
    next
  }
  
  # Set factor levels for Stage to match the order of time_diff_vars
  plot_data$Stage <- factor(plot_data$Stage, levels = time_diff_vars)
  
  # Calculate summary statistics
  summary_points <- plot_data %>%
    group_by(Stage) %>%
    summarize(
      median = round(median(Days, na.rm = TRUE)),
      min = round(min(Days, na.rm = TRUE)),
      max = round(max(Days, na.rm = TRUE))
    ) %>%
    ungroup() %>%
    mutate(general = group)  # Add the 'general' value to the summary
  
  # Append the results to the final data frame
  summary_stats_general <- rbind(summary_stats_general, summary_points)
}

# Reorder columns to match the desired output format
summary_stats_general <- summary_stats_general %>%
  select(general, Stage, median, min, max)

# Display the resulting data frame
print(summary_stats_general)

xl_10 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\df_majorstages_category.xlsx"

# Export the data frame to Excel
write_xlsx(summary_stats_general, path = xl_10)
```
 
#Data frame for major stages by sector 

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Define the time difference variables
time_diff_vars <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", 
                    "days_src_subsidy")

# Create a data frame to store the results based on the 'project_sector' variable
summary_stats_project_sector <- data.frame(
  project_sector = character(),
  Stage = character(),
  median = numeric(),
  min = numeric(),
  max = numeric(),
  stringsAsFactors = FALSE
)

# Check unique values in 'project_sector'
unique_project_sector_values <- unique(df_clean$project_sector)
print(paste("Unique values in 'project_sector':", unique(unique_project_sector_values)))

# Loop over each unique value in the 'project_sector' variable and calculate summary statistics
for (sector in unique_project_sector_values) {
  cat("Processing sector:", sector, "\n")  # Debugging line

  # Filter the data for the current 'project_sector' value
  filtered_df <- df_clean %>%
    filter(project_sector == sector) %>%
    mutate(across(all_of(time_diff_vars), ~ ifelse(. < 0, NA, .)))
  
  # Check if filtered data is empty
  if (nrow(filtered_df) == 0) {
    cat("No data for sector:", sector, "\n")  # Debugging line
    next
  }

  # Gather data for processing
  plot_data <- filtered_df %>%
    select(all_of(time_diff_vars)) %>%
    pivot_longer(everything(), names_to = "Stage", values_to = "Days") %>%
    filter(!is.na(Days))
  
  # Check if plot_data is empty
  if (nrow(plot_data) == 0) {
    cat("No valid data for sector:", sector, "\n")  # Debugging line
    next
  }
  
  # Set factor levels for Stage to match the order of time_diff_vars
  plot_data$Stage <- factor(plot_data$Stage, levels = time_diff_vars)
  
  # Calculate summary statistics
  summary_points <- plot_data %>%
    group_by(Stage) %>%
    summarize(
      median = round(median(Days, na.rm = TRUE)),
      min = round(min(Days, na.rm = TRUE)),
      max = round(max(Days, na.rm = TRUE))
    ) %>%
    ungroup() %>%
    mutate(project_sector = sector)  # Add the 'project_sector' value to the summary
  
  # Append the results to the final data frame
  summary_stats_project_sector <- rbind(summary_stats_project_sector, summary_points)
}

# Reorder columns to match the desired output format
summary_stats_project_sector <- summary_stats_project_sector %>%
  select(project_sector, Stage, median, min, max)

# Display the resulting data frame
print(summary_stats_project_sector)


xl_11 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\df_majorstages_sector.xlsx"

# Export the data frame to Excel
write_xlsx(summary_stats_project_sector, path = xl_11)
```

  
  
#Data frame for major stages by mode of finance
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Define the time difference variables
time_diff_vars <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", 
                    "days_src_subsidy")

# Create a data frame to store the results based on the 'mode_of_finance' variable
summary_stats_mode_of_finance <- data.frame(
  mode_of_finance = character(),
  Stage = character(),
  median = numeric(),
  min = numeric(),
  max = numeric(),
  stringsAsFactors = FALSE
)

# Check unique values in 'mode_of_finance'
unique_mode_of_finance_values <- unique(df_clean$mode_of_finance)
print(paste("Unique values in 'mode_of_finance':", unique(unique_mode_of_finance_values)))

# Loop over each unique value in the 'mode_of_finance' variable and calculate summary statistics
for (finance_mode in unique_mode_of_finance_values) {
  cat("Processing mode of finance:", finance_mode, "\n")  # Debugging line

  # Filter the data for the current 'mode_of_finance' value
  filtered_df <- df_clean %>%
    filter(mode_of_finance == finance_mode) %>%
    mutate(across(all_of(time_diff_vars), ~ ifelse(. < 0, NA, .)))
  
  # Check if filtered data is empty
  if (nrow(filtered_df) == 0) {
    cat("No data for mode of finance:", finance_mode, "\n")  # Debugging line
    next
  }

  # Gather data for processing
  plot_data <- filtered_df %>%
    select(all_of(time_diff_vars)) %>%
    pivot_longer(everything(), names_to = "Stage", values_to = "Days") %>%
    filter(!is.na(Days))
  
  # Check if plot_data is empty
  if (nrow(plot_data) == 0) {
    cat("No valid data for mode of finance:", finance_mode, "\n")  # Debugging line
    next
  }
  
  # Set factor levels for Stage to match the order of time_diff_vars
  plot_data$Stage <- factor(plot_data$Stage, levels = time_diff_vars)
  
  # Calculate summary statistics
  summary_points <- plot_data %>%
    group_by(Stage) %>%
    summarize(
      median = round(median(Days, na.rm = TRUE)),
      min = round(min(Days, na.rm = TRUE)),
      max = round(max(Days, na.rm = TRUE))
    ) %>%
    ungroup() %>%
    mutate(mode_of_finance = finance_mode)  # Add the 'mode_of_finance' value to the summary
  
  # Append the results to the final data frame
  summary_stats_mode_of_finance <- rbind(summary_stats_mode_of_finance, summary_points)
}

# Reorder columns to match the desired output format
summary_stats_mode_of_finance <- summary_stats_mode_of_finance %>%
  select(mode_of_finance, Stage, median, min, max)

# Display the resulting data frame
print(summary_stats_mode_of_finance)


xl_12 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\df_majorstages_mof.xlsx"

# Export the data frame to Excel
write_xlsx(summary_stats_mode_of_finance, path = xl_12)
```

  
#Data frame for sub stages by category (General and Special)
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Define the variables of interest
days_vars <- c("days_reg_blo", "days_blo_dno", "days_dno_collector",
               "days_collector_apicoldm", "days_apicoldm_goahead", 
               "days_goahead_sanction", "days_sanction_complete",
               "days_complete_blo_inspect", "days_blo_inspect_dno_comp", 
               "days_dno_comp_admin", "days_admin_src", "days_src_subsidy")

# Create an empty data frame to store the results
summary_stats_general <- data.frame(
  general = character(),
  vars = character(),
  median = numeric(),
  min = numeric(),
  max = numeric(),
  stringsAsFactors = FALSE
)

# Get the unique categories of the 'general' variable
unique_general_categories <- unique(df_clean$general)

# Loop over each category in 'general' and each variable in 'days_vars'
for (general_category in unique_general_categories) {
  for (var in days_vars) {
    
    # Filter the data for the current category and remove negative values
    filtered_data <- df_clean %>%
      filter(general == general_category) %>%
      select(all_of(var)) %>%
      pull() %>%
      .[. >= 0]  # Remove negative values
    
    # Calculate summary statistics if there's data left after filtering
    if (length(filtered_data) > 0) {
      median_val <- round(median(filtered_data, na.rm = TRUE))
      min_val <- round(min(filtered_data, na.rm = TRUE))
      max_val <- round(max(filtered_data, na.rm = TRUE))
      
      # Append the results to the final data frame
      summary_stats_general <- rbind(summary_stats_general, 
                                     data.frame(general = general_category, 
                                                vars = var, 
                                                median = median_val, 
                                                min = min_val, 
                                                max = max_val))
    }
  }
}

# Display the resulting data frame
print(summary_stats_general)

xl_13 <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\df_substages_general.xlsx"

# Export the data frame to Excel
write_xlsx(summary_stats_general, path = xl_13)

```


#Kernels for sub stages of Inspection Stage (common to all applicants)

Sub-stages
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(ggplot2)
library(dplyr)
library(gridExtra)

# Function to plot distribution with kernel density centered around the median
plot_distribution <- function(data, var, custom_title = NULL) {
  # Filter out negative values
  data_filtered <- data %>% filter(!is.na(data[[var]]) & data[[var]] >= 0)
  
  # Calculate median and number of observations
  median_value <- median(data_filtered[[var]], na.rm = TRUE)
  num_obs <- sum(!is.na(data_filtered[[var]]))
  
  # Set the title
  plot_title <- ifelse(is.null(custom_title), paste("Distribution of", var), custom_title)
  
  ggplot(data_filtered, aes_string(x = var)) +
    geom_density(fill = "lightblue", alpha = 0.5) +  # Plot density
    geom_vline(aes(xintercept = median_value), color = "red", linetype = "dashed", size = 1) +  # Add median line
    geom_text(aes(x = median_value, y = 0, label = paste("Median =", median_value)), 
              vjust = -1, color = "red", size = 4) +  # Label median
    geom_text(aes(x = Inf, y = Inf, label = paste("N =", num_obs)), 
              hjust = 1.5, vjust = 2, size = 4, color = "black") +  # Label number of observations
    labs(
      title = plot_title,
      x = var,
      y = "Density"
    ) +
    theme_minimal()
}

# Variables to plot with custom titles
variables <- c("days_complete_blo_inspect", "days_blo_inspect_dno_comp", "days_dno_comp_admin", "days_admin_src")
titles <- c("Completion to BLO Inspection", "BLO Inspection to DNO Comparative", "DNO Comparative to Admin Comparative", "Admin Comparative to SRC")

# Generate plots with custom titles
plots <- mapply(function(var, title) plot_distribution(df_clean_filtered, var, title), 
                variables, titles, SIMPLIFY = FALSE)

# Display plots
do.call(grid.arrange, plots)

 
```

Kernel for new sub stage (Admin comparative to Subsidy Release) 
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Parameters for line widths and font sizes
median_line_width <- 0.75  # Width for the median line
medium_font_size <- 4  # Font size for labels

# Filter out negative values for 'days_admin_subsidy'
data_filtered <- df_clean %>%
  filter(!is.na(days_admin_subsidy) & days_admin_subsidy > 0)

# Compute median and number of observations
median_value <- median(data_filtered$days_admin_subsidy, na.rm = TRUE)
num_obs <- sum(!is.na(data_filtered$days_admin_subsidy))

# Generate and display the kernel density plot
ggplot(data_filtered, aes(x = days_admin_subsidy)) +
  geom_density(fill = "lightblue", alpha = 0.5) +  # Plot density
  geom_vline(aes(xintercept = median_value), color = "red", linetype = "dashed", size = median_line_width) +  # Add median line
  geom_text(aes(x = median_value, y = 0, label = paste("Median =", median_value)), 
            vjust = -1, color = "red", size = medium_font_size) +  # Label median
  geom_text(aes(x = Inf, y = Inf, label = paste("N =", num_obs)), 
            hjust = 1.5, vjust = 2, size = medium_font_size, color = "black") +  # Label number of observations
  labs(
    title = "Admin Comparative to Subsidy",
    x = "days_admin_subsidy",
    y = "Density"
  ) +
  theme_minimal()

```
 
 
#Kernels for all major stages
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Load necessary libraries
library(ggplot2)
library(gridExtra)
library(dplyr)

# Function to plot distribution with kernel density centered around the median
plot_distribution <- function(data, var, benchmark, benchmark_label, title) {
  # Filter out negative values
  data_filtered <- data %>% filter(get(var) > 0)
  
  # Compute median and number of observations
  median_value <- median(data_filtered[[var]], na.rm = TRUE)
  num_obs <- sum(!is.na(data_filtered[[var]]))
  
  # Plot
  ggplot(data_filtered, aes_string(x = var)) +
    geom_density(fill = "lightblue", alpha = 0.5) +  # Plot density
    geom_vline(aes(xintercept = median_value), color = "red", linetype = "dashed", size = median_line_width) +  # Add median line
    geom_vline(aes(xintercept = benchmark), color = "blue", linetype = "dotted", size = benchmark_line_width) +  # Add benchmark line
    geom_text(aes(x = median_value, y = 0, label = paste("Median =", median_value)), 
              vjust = -1, color = "red", size = medium_font_size) +  # Label median
    geom_text(aes(x = benchmark, y = 0, label = benchmark_label), 
              vjust = -1, color = "blue", size = medium_font_size) +  # Label benchmark
    geom_text(aes(x = Inf, y = Inf, label = paste("N =", num_obs)), 
              hjust = 1.5, vjust = 2, size = medium_font_size, color = "black") +  # Label number of observations
    labs(
      title = title,
      x = var,
      y = "Density"
    ) +
    theme_minimal()
}

# Parameters for line widths and font sizes
median_line_width <- 0.75  # Width for the median line
benchmark_line_width <- 0.75  # Width for the benchmark lines
medium_font_size <- 4  # Font size for labels

# Variables, benchmarks, benchmark labels, and titles
variables <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", "days_src_subsidy")
benchmarks <- c(52, 730, 80, 7)  # Benchmarks for each variable
benchmark_labels <- c("52", "730", "80", "7")  # Labels for benchmark lines
titles <- c("Stage 1: Registration to Go Ahead", "Stage 2: Go Ahead to Completion", 
            "Stage 3: Completion to SRC", "Stage 4: SRC to Subsidy Release")  # Titles

# Generate plots for each variable with its benchmark
plots <- mapply(function(var, benchmark, benchmark_label, title) {
  plot_distribution(df_clean_filtered, var, benchmark, benchmark_label, title)
}, variables, benchmarks, benchmark_labels, titles, SIMPLIFY = FALSE)

# Arrange plots in a grid
grid.arrange(grobs = plots, ncol = 2)  # Adjust `ncol` to arrange the plots in two columns




```

  
#Plot 23: Distributions for all major stages: Histogram with kernel density overlay
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Updated function to plot histogram with density overlay
plot_histogram_density <- function(data, var, benchmark, benchmark_label, title,
                                   bin_count = 30, median_line_color = "blue", 
                                   benchmark_line_color = "red", fill_color = "lightblue",
                                   alpha_fill = 0.5, density_color = "darkblue", 
                                   median_line_type = "dashed", benchmark_line_type = "solid",
                                   line_size = 0.75, font_size = 12, x_label = "Number of Days", y_label = "Density",
                                   median_hjust = 1, median_vjust = 1,  # Adjust median label position
                                   benchmark_hjust = 0.5, benchmark_vjust = -1) {  # Adjust benchmark label position
  
  # Filter out negative values
  data_filtered <- data %>% filter(get(var) > 0)
  
  # Compute median value
  median_value <- median(data_filtered[[var]], na.rm = TRUE)
  
  # Dynamically adjust bin width based on the range of the data
  range_var <- range(data_filtered[[var]], na.rm = TRUE)
  binwidth <- (range_var[2] - range_var[1]) / bin_count  # Adjust number of bins as necessary

  # Create the plot with no legends, solid benchmark line, and customized y-axis labels
  ggplot(data_filtered, aes_string(x = var)) +
    geom_histogram(aes(y = ..density..), binwidth = binwidth, fill = fill_color, alpha = alpha_fill) +  # Histogram with density
    geom_density(color = density_color, size = line_size) +  # Overlay density plot
    geom_vline(xintercept = median_value, color = median_line_color, 
               linetype = median_line_type, size = line_size) +  # Add median line
    geom_vline(xintercept = as.numeric(benchmark), color = benchmark_line_color, 
               linetype = benchmark_line_type, size = line_size) +  # Add solid benchmark line
    geom_text(aes(x = median_value, y = 0, label = format(round(median_value, 0), nsmall = 0)), 
              hjust = median_hjust, vjust = median_vjust, color = median_line_color, size = font_size - 7) +  # Label median with adjustable position
    geom_text(aes(x = as.numeric(benchmark), y = 0, label = benchmark_label), 
              hjust = benchmark_hjust, vjust = benchmark_vjust, color = benchmark_line_color, size = font_size - 7) +  # Label benchmark with adjustable position
    labs(
      title = title,  # Custom plot title
      x = x_label,
      y = y_label
    ) +
    scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +  # y-axis labels to 2 decimal places
    theme_minimal() +
    theme(
      legend.position = "none",  # Remove legend
      axis.title = element_text(size = font_size + 5),  # Adjust axis title font size
      axis.text = element_text(size = font_size),  # Adjust axis label font size
      plot.title = element_text(size = font_size + 6, face = "bold")  # Adjust plot title font size
    )
}

# Example of calling the function with customized label positions
histogram_density_plots <- mapply(function(var, benchmark, benchmark_label, title) {
  plot_histogram_density(df_clean_filtered, var, benchmark, benchmark_label, title, 
                         median_hjust = 1, median_vjust = -1,  # Adjust median label position
                         benchmark_hjust = -0.1, benchmark_vjust = -2)  # Adjust benchmark label position
}, majorstages, benchmarks, benchmark_labels, titles, SIMPLIFY = FALSE)

# Arrange plots in a grid
plot_23 <- grid.arrange(grobs = histogram_density_plots, ncol = 2)
print(plot_23)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_23.png", 
       plot = plot_23, width = 12, height = 10, dpi = 300)

```

#Separate plots for Plot 23 grid  
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Function to plot histogram with density overlay without titles
plot_histogram_density <- function(data, var, benchmark, benchmark_label) {
  # Filter out negative values
  data_filtered <- data %>% filter(get(var) > 0)
  
  # Compute median and number of observations
  median_value <- median(data_filtered[[var]], na.rm = TRUE)
  num_obs <- sum(!is.na(data_filtered[[var]]))
  
  # Define colors for the lines
  line_colors <- c("Median" = "blue", "Benchmark" = "red")
  
  # Create the plot without title
  ggplot(data_filtered, aes_string(x = var)) +
    geom_histogram(aes(y = ..density..), binwidth = 1, fill = "lightblue", alpha = 0.5) +  # Histogram with density
    geom_density(color = "darkblue", size = 1) +  # Overlay density plot
    geom_vline(aes(xintercept = median_value, color = "Median"), 
               linetype = "dashed", size = median_line_width, show.legend = TRUE) +  # Add median line with legend
    geom_vline(aes(xintercept = benchmark, color = "Benchmark"), 
               linetype = "dotted", size = benchmark_line_width, show.legend = TRUE) +  # Add benchmark line with legend
    scale_color_manual(name = "Lines", values = line_colors) +  # Custom legend for vlines
    geom_text(aes(x = median_value, y = 0, label = paste("", median_value)), 
              vjust = -1, color = "blue", size = medium_font_size) +  # Label median
    geom_text(aes(x = benchmark, y = 0, label = benchmark_label), 
              vjust = -1, color = "red", size = medium_font_size) +  # Label benchmark
    geom_text(aes(x = Inf, y = Inf, label = paste("N =", num_obs)), 
              hjust = 1.5, vjust = 2, size = medium_font_size, color = "black") +  # Label number of observations
    labs(
      x = "Number of Days",
      y = "Density"
    ) +
    theme_minimal() +
    theme(legend.position = "top")  # Position legend at the top
}

# Loop through each variable to generate and save plots
for (i in seq_along(variables)) {
  # Generate the plot for the current variable
  plot <- plot_histogram_density(
    data = df_clean_filtered,
    var = variables[i],
    benchmark = benchmarks[i],
    benchmark_label = benchmark_labels[i]
  )
  
  # Print the plot to display
  print(plot)
  
  # Save each plot to a file (e.g., as PNG)
  ggsave(filename = paste0("plot_", variables[i], ".png"), plot = plot, width = 8, height = 6)
}


```




#Plots    : Stage 2 for Bank and Self 
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Define the variables for Stage 2 (update these based on your data)
stage_2_vars <- c("days_goahead_complete")
# Loop through each mode of finance and each variable in Stage 2
for (finance_mode in c("Bank Loan", "Self")) {
  # Filter the data for the current mode of finance
  data_filtered <- df_clean_filtered %>% filter(mode_of_finance == finance_mode)
  
  # Generate and save plots for each variable in Stage 2
  for (var in stage_2_vars) {
    # Define the title and benchmark values (adjust as needed)
    title <- paste("")
    benchmark <- ifelse(var == "days_goahead_sanction", 730, 730)  # Example benchmark values
    benchmark_label <- paste(benchmark, "days")
    
    # Generate the plot
    plot <- plot_histogram_density(
      data = data_filtered,
      var = var,
      benchmark = benchmark,
      benchmark_label = benchmark_label,
      title = title
    )
    
    # Print the plot to display
    print(plot)
    
    # Optionally, save each plot to a file
    ggsave(filename = paste0("plot_", var, "_", finance_mode, ".png"), plot = plot, width = 8, height = 6)
  }
}

```



#-------------------Investigating the first and fourth quartiles of the major stages----------------------------

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# List of variables to calculate quartile counts for
variables <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", "days_src_subsidy", "days_goahead_sanction")

# Initialize an empty list to store quartile counts for each variable
quartile_counts_list <- list()

# Loop through the variables and calculate quartile counts
for (var in variables) {
  # Calculate quartiles and categorize the values
  quartile_categories <- cut(
    df_clean[[var]], 
    breaks = quantile(df_clean[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = FALSE
  )
  
  # Count the number of values in each quartile
  quartile_counts <- as.numeric(table(quartile_categories, useNA = "no"))
  
  # Store the counts in the list, with the variable name as the list element name
  quartile_counts_list[[var]] <- quartile_counts
}

# Combine the counts into a data frame
wide_quartile_counts <- do.call(rbind, quartile_counts_list)

# Convert to a data frame and add column names
wide_quartile_counts <- data.frame(Variable = rownames(wide_quartile_counts), wide_quartile_counts)
colnames(wide_quartile_counts) <- c("Variable", "Q1", "Q2", "Q3", "Q4")

# Reset row names
rownames(wide_quartile_counts) <- NULL

# Print the final wide-format data frame
print(wide_quartile_counts)


```

##Quartiles and Sectors for Stage 1

```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}

rm(df_clean_sorted)
# Check if the number of rows matches the expectation
initial_row_count <- nrow(df_clean)

# Sort the data by the days_reg_goahead variable, retaining duplicates
df_clean_sorted <- df_clean[order(df_clean$days_reg_goahead), ]

# Calculate quartiles, including NA values in the output
quartile_categories_sorted <- cut(
  df_clean_sorted$days_reg_goahead, 
  breaks = quantile(df_clean_sorted$days_reg_goahead, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
  include.lowest = TRUE, 
  labels = FALSE
)

# Check if the number of rows after sorting still matches the initial row count
sorted_row_count <- nrow(df_clean_sorted)

# Add quartile categories to the sorted data frame
df_clean_sorted$quartile_category <- quartile_categories_sorted

# Check for NA values in the quartile categories
na_quartile_count <- sum(is.na(df_clean_sorted$quartile_category))

# Analyze the count of observations for each sector within each quartile
quartile_sector_counts <- table(df_clean_sorted$quartile_category, df_clean_sorted$sectors, useNA = "ifany")

# Convert the result to a data frame
quartile_sector_df <- as.data.frame.matrix(quartile_sector_counts)

# Check if the total counts across all sectors match the expected 6468 observations
total_count <- sum(quartile_sector_df)

# Print diagnostics
print(paste("Initial Row Count:", initial_row_count))
print(paste("Sorted Row Count:", sorted_row_count))
print(paste("NA in Quartile Categories:", na_quartile_count))
print(paste("Total Count in Quartile-Sector Analysis:", total_count))

# Print the resulting data frame
print(quartile_sector_df)




```



##First and Fourth Quartiles by Fixed Cost Size
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(gridExtra)
library(scales)

# Define the variables to analyze
variables <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", "days_src_subsidy")

# Define custom titles for each plot
plot_titles <- list(
  "days_reg_goahead" = "Days Between Registration and Go-Ahead",
  "days_goahead_complete" = "Days Between Go-Ahead and Completion",
  "days_complete_src" = "Days Between Completion and SRC",
  "days_src_subsidy" = "Days Between SRC and Subsidy"
)

# Step 1: Create 'fixed_cost_range' in df_clean
df_clean <- df_clean %>%
  filter(!is.na(fixed_cost)) %>%
  mutate(fixed_cost_range = cut(fixed_cost,
                                breaks = c(0, 2500000, 5000000, 10000000, Inf),
                                labels = c("Below 25 lakhs", "25-50 lakhs", "50 lakhs-1 crore", "Above 1 crore"),
                                right = FALSE))

# Step 2: Calculate the counts for each fixed_cost_range within each quartile of the variables
quartile_counts_list <- list()

for (var in variables) {
  df_clean_q_size <- df_clean %>%
    mutate(!!paste0(var, "_quartile") := cut(
      .data[[var]], 
      breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
      include.lowest = TRUE, 
      labels = c("Q1", "Q2", "Q3", "Q4")
    )) %>%
    filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories
  
  quartile_counts <- df_clean_q_size %>%
    group_by_at(c(paste0(var, "_quartile"), "fixed_cost_range")) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    mutate(Variable = var)
  
  quartile_counts <- quartile_counts %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count))  # Calculate percentage within each quartile
  
  quartile_counts_list[[var]] <- quartile_counts
}

# Step 3: Combine the counts into a single data frame
combined_quartile_counts <- bind_rows(quartile_counts_list)

# Generate individual plots for each variable without a specific color palette
plot_list <- lapply(variables, function(var) {
  df_plot <- filter(combined_quartile_counts, Variable == var)
  
  ggplot(df_plot, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = fixed_cost_range)) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 3) +
    labs(title = plot_titles[[var]],  # Use the custom title for the plot
         x = "Quartile",
         y = "Number of Projects",
         fill = "Fixed Cost Range") +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 7))
})

# Arrange the plots in a grid
do.call(grid.arrange, c(plot_list, ncol = 2))

print(combined_quartile_counts)




```

##First and Fourth Quartiles by Sector 
 
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(gridExtra)
library(scales)

# Define the variables to analyze
variables <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", "days_src_subsidy")

# Define custom titles for each plot
plot_titles <- list(
  "days_reg_goahead" = "Days Between Registration and Go-Ahead",
  "days_goahead_complete" = "Days Between Go-Ahead and Completion",
  "days_complete_src" = "Days Between Completion and SRC",
  "days_src_subsidy" = "Days Between SRC and Subsidy"
)

# Step 1: Create 'sector' in df_clean if not already present
# Assuming 'sector' is already present in df_clean

# Step 2: Calculate the counts for each sector within each quartile of the variables
sector_counts_list <- list()

for (var in variables) {
  df_clean_q_sectors <- df_clean %>%
    mutate(!!paste0(var, "_quartile") := cut(
      .data[[var]], 
      breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
      include.lowest = TRUE, 
      labels = c("Q1", "Q2", "Q3", "Q4")
    )) %>%
    filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories
  
  # Keep duplicates
  sector_counts <- df_clean_q_sectors %>%
    group_by_at(c(paste0(var, "_quartile"), "sectors")) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count), Variable = var)  # Add Variable column here
  
  sector_counts_list[[var]] <- sector_counts
}

# Step 3: Combine the counts into a single data frame
combined_sector_counts <- bind_rows(sector_counts_list)

# Sort the quartile factor levels explicitly to ensure correct order
for (var in variables) {
  combined_sector_counts <- combined_sector_counts %>%
    mutate(!!paste0(var, "_quartile") := factor(
      .data[[paste0(var, "_quartile")]],
      levels = c("Q1", "Q2", "Q3", "Q4")
    ))
}

# Generate individual plots for each variable with sectors instead of fixed_cost_range
plot_list <- lapply(variables, function(var) {
  df_plot <- filter(combined_sector_counts, Variable == var)
  
  ggplot(df_plot, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = sectors)) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 3) +
    labs(title = plot_titles[[var]],  # Use the custom title for the plot
         x = "Quartile",
         y = "Number of Projects",
         fill = "Sector") +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 7))
})

# Arrange the plots in a grid
do.call(grid.arrange, c(plot_list, ncol = 2))

# Print the combined_sector_counts data frame
print(combined_sector_counts)


```
 
 
 
##First and Fourth Quartiles by Mode of Finance
 
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(gridExtra)
library(scales)

# Define the variables to analyze
variables <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", "days_src_subsidy")

# Define custom titles for each plot
plot_titles <- list(
  "days_reg_goahead" = "Days Between Registration and Go-Ahead",
  "days_goahead_complete" = "Days Between Go-Ahead and Completion",
  "days_complete_src" = "Days Between Completion and SRC",
  "days_src_subsidy" = "Days Between SRC and Subsidy"
)

# Step 1: Create 'mode_of_finance' in df_clean if not already present
# Assuming 'mode_of_finance' is already present in df_clean

# Step 2: Calculate the counts for each mode_of_finance within each quartile of the variables
mode_of_finance_counts_list <- list()

for (var in variables) {
  df_clean_q_mof <- df_clean %>%
    mutate(!!paste0(var, "_quartile") := cut(
      .data[[var]], 
      breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
      include.lowest = TRUE, 
      labels = c("Q1", "Q2", "Q3", "Q4")
    )) %>%
    filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories
  
  mode_of_finance_counts <- df_clean_q_mof %>%
    group_by_at(c(paste0(var, "_quartile"), "mode_of_finance")) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    mutate(Variable = var)
  
  mode_of_finance_counts <- mode_of_finance_counts %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count))  # Calculate percentage within each quartile
  
  mode_of_finance_counts_list[[var]] <- mode_of_finance_counts
}

# Step 3: Combine the counts into a single data frame
combined_mode_of_finance_counts <- bind_rows(mode_of_finance_counts_list)

# Generate individual plots for each variable with mode_of_finance instead of sectors
plot_list <- lapply(variables, function(var) {
  df_plot <- filter(combined_mode_of_finance_counts, Variable == var)
  
  ggplot(df_plot, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = mode_of_finance)) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 3) +
    labs(title = plot_titles[[var]],  # Use the custom title for the plot
         x = "Quartile",
         y = "Number of Projects",
         fill = "Mode of Finance") +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 7))
})

# Arrange the plots in a grid
do.call(grid.arrange, c(plot_list, ncol = 2))

# Print the combined_mode_of_finance_counts data frame
print(combined_mode_of_finance_counts)

```

 
 
 
 
 
 
 
 
 
 
##Plot 24: First and Fourth Quartiles for Stage 1 by size, sector, mode of finance and category

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(gridExtra)

# Define variable
var <- "days_reg_goahead"

# Create quartiles based on the variable and store the result in df_clean_24
df_clean_24 <- df_clean_filtered %>%
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories

# Function to calculate counts and percentages
calculate_counts_percentages <- function(df, group_var) {
  df %>%
    group_by_at(c(paste0(var, "_quartile"), group_var)) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count)) %>%
    ungroup()
}

# Calculate counts and percentages for each grouping variable using df_clean_24
project_cost_counts <- calculate_counts_percentages(df_clean_24, "project_cost_range")
sectors_counts <- calculate_counts_percentages(df_clean_24, "sectors")
mode_of_finance_counts <- calculate_counts_percentages(df_clean_24, "mode_of_finance")
general_counts <- calculate_counts_percentages(df_clean_24, "general")

# Function to create a stacked bar plot with labels
create_stacked_bar_plot <- function(df, fill_var, title) {
  ggplot(df, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = .data[[fill_var]])) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 2.5) +
    labs(title = title, 
         x = "Quartile", 
         y = "Number of Applications", 
         fill = fill_var) +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 8))
}

# Create plots
plot_project_cost <- create_stacked_bar_plot(project_cost_counts, "project_cost_range", "Stage 1 by Project Cost Range")
plot_sectors <- create_stacked_bar_plot(sectors_counts, "sectors", "Stage 1 by Sectors")
plot_mode_of_finance <- create_stacked_bar_plot(mode_of_finance_counts, "mode_of_finance", "Stage 1 by Mode of Finance")
plot_general <- create_stacked_bar_plot(general_counts, "general", "Stage 1 by Subsidy Category")

# Arrange the plots in a 2x2 grid
plot_24 <- grid.arrange(plot_project_cost, plot_sectors, plot_mode_of_finance, plot_general, ncol = 2, nrow = 2)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_24.png", 
       plot = plot_24, width = 12, height = 10, dpi = 300)

# Filter data for the fourth quartile using df_clean_24
df_q4 <- df_clean_24 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Count of project_type within each sector in the fourth quartile
sector_project_type_counts <- df_q4 %>%
  group_by(sectors, project_type) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  arrange(sectors, desc(Count))  # Arrange in descending order of Count within each sector

# Print the resulting data frame
print(sector_project_type_counts)
rm(df_clean_24)
rm(df_q4)

```
 
##Plot 25: First and Fourth Quartiles for Stage 2 by size, sector, mode of finance and category
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(gridExtra)

# Define variable
var <- "days_goahead_complete"

# Create quartiles based on the variable
df_clean_25 <- df_clean_filtered %>%
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories

# Function to calculate counts and percentages
calculate_counts_percentages <- function(df, group_var) {
  df %>%
    group_by_at(c(paste0(var, "_quartile"), group_var)) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count)) %>%
    ungroup()
}

# Calculate counts and percentages for each grouping variable
project_cost_counts <- calculate_counts_percentages(df_clean_25, "project_cost_range")
sectors_counts <- calculate_counts_percentages(df_clean_25, "sectors")
mode_of_finance_counts <- calculate_counts_percentages(df_clean_25, "mode_of_finance")
general_counts <- calculate_counts_percentages(df_clean_25, "general")

# Function to create a stacked bar plot with labels
create_stacked_bar_plot <- function(df, fill_var, title) {
  ggplot(df, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = .data[[fill_var]])) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 2.5) +
    labs(title = title, 
         x = "Quartile", 
         y = "Number of Applications", 
         fill = fill_var) +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 8))
}

# Create plots
plot_project_cost <- create_stacked_bar_plot(project_cost_counts, "project_cost_range", "Stage 2 by Project Cost Range")
plot_sectors <- create_stacked_bar_plot(sectors_counts, "sectors", "Stage 2 by Sectors")
plot_mode_of_finance <- create_stacked_bar_plot(mode_of_finance_counts, "mode_of_finance", "Stage 2 by Mode of Finance")
plot_general <- create_stacked_bar_plot(general_counts, "general", "Stage 2 by Subsidy Category")

# Arrange the plots in a 2x2 grid
plot_25 <- grid.arrange(plot_project_cost, plot_sectors, plot_mode_of_finance, plot_general, ncol = 2, nrow = 2)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_25.png", 
       plot = plot_25, width = 12, height = 10, dpi = 300)

# Filter data for the fourth quartile
df_q4 <- df_clean_25 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Count of project_type within each sector in the fourth quartile
sector_project_type_counts <- df_q4 %>%
  group_by(sectors, project_type) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  arrange(sectors, desc(Count))  # Arrange in descending order of Count within each sector

# Print the resulting data frame
print(sector_project_type_counts)

```
 
##Plot 26: First and Fourth Quartiles for Stage 3 by size, sector, mode of finance and category 
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(gridExtra)

# Define variable
var <- "days_complete_src"

# Create quartiles based on the variable
df_clean_26 <- df_clean_filtered %>%
  mutate(days_complete_src_quartile = cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(days_complete_src_quartile))  # Exclude NA quartile categories

# Function to calculate counts and percentages
calculate_counts_percentages <- function(df, group_var) {
  df %>%
    group_by(days_complete_src_quartile, .data[[group_var]]) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    group_by(days_complete_src_quartile) %>%
    mutate(Percentage = Count / sum(Count)) %>%
    ungroup()
}

# Calculate counts and percentages for each grouping variable
project_cost_counts <- calculate_counts_percentages(df_clean_26, "project_cost_range")
sectors_counts <- calculate_counts_percentages(df_clean_26, "sectors")
mode_of_finance_counts <- calculate_counts_percentages(df_clean_26, "mode_of_finance")
general_counts <- calculate_counts_percentages(df_clean_26, "general")

# Function to create a stacked bar plot with labels
create_stacked_bar_plot <- function(df, fill_var, title) {
  ggplot(df, aes(x = days_complete_src_quartile, y = Count, fill = .data[[fill_var]])) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 2.5) +
    labs(title = title, 
         x = "Quartile", 
         y = "Number of Applications", 
         fill = fill_var) +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 8))
}

# Create plots
plot_project_cost <- create_stacked_bar_plot(project_cost_counts, "project_cost_range", "Stage 3 by Project Cost Range")
plot_sectors <- create_stacked_bar_plot(sectors_counts, "sectors", "Stage 3 by Sectors")
plot_mode_of_finance <- create_stacked_bar_plot(mode_of_finance_counts, "mode_of_finance", "Stage 3 by Mode of Finance")
plot_general <- create_stacked_bar_plot(general_counts, "general", "Stage 3 by Subsidy Category")

# Arrange the plots in a 2x2 grid
plot_26 <- grid.arrange(plot_project_cost, plot_sectors, plot_mode_of_finance, plot_general, ncol = 2, nrow = 2)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_26.png", 
       plot = plot_26, width = 12, height = 10, dpi = 300)

# Filter data for the fourth quartile
df_q4 <- df_clean_26 %>%
  filter(days_complete_src_quartile == "Q4")

# Count of project_type within each sector in the fourth quartile
sector_project_type_counts <- df_q4 %>%
  group_by(sectors, project_type) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  arrange(sectors, desc(Count))  # Arrange in descending order of Count within each sector

# Print the resulting data frame
print(sector_project_type_counts)

```
 
 
##Plot 27: First and Fourth Quartiles for Stage 4 by size, sector, mode of finance and category 
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(gridExtra)

# Define variable
var <- "days_src_subsidy"

# Create quartiles based on the variable
df_clean_27 <- df_clean_filtered %>%
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories

# Function to calculate counts and percentages
calculate_counts_percentages <- function(df, group_var) {
  df %>%
    group_by_at(c(paste0(var, "_quartile"), group_var)) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count)) %>%
    ungroup()
}

# Calculate counts and percentages for each grouping variable
project_cost_counts <- calculate_counts_percentages(df_clean_27, "project_cost_range")
sectors_counts <- calculate_counts_percentages(df_clean_27, "sectors")
mode_of_finance_counts <- calculate_counts_percentages(df_clean_27, "mode_of_finance")
general_counts <- calculate_counts_percentages(df_clean_27, "general")

# Function to create a stacked bar plot with labels
create_stacked_bar_plot <- function(df, fill_var, title) {
  ggplot(df, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = .data[[fill_var]])) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 2.5) +
    labs(title = title, 
         x = "Quartile", 
         y = "Number of Applications", 
         fill = fill_var) +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 8))
}

# Create plots
plot_project_cost <- create_stacked_bar_plot(project_cost_counts, "project_cost_range", "Stage 4 by Project Cost Range")
plot_sectors <- create_stacked_bar_plot(sectors_counts, "sectors", "Stage 4 by Sectors")
plot_mode_of_finance <- create_stacked_bar_plot(mode_of_finance_counts, "mode_of_finance", "Stage 4 by Mode of Finance")
plot_general <- create_stacked_bar_plot(general_counts, "general", "Stage 4 by Subsidy Category")

# Arrange the plots in a 2x2 grid
plot_27 <- grid.arrange(plot_project_cost, plot_sectors, plot_mode_of_finance, plot_general, ncol = 2, nrow = 2)

print(plot_27)
# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_27.png", 
       plot = plot_27, width = 12, height = 10, dpi = 300)

# Filter data for the fourth quartile
df_q4 <- df_clean_27 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Count of project_type within each sector in the fourth quartile
sector_project_type_counts <- df_q4 %>%
  group_by(sectors, project_type) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  arrange(sectors, desc(Count))  # Arrange in descending order of Count within each sector

# Print the resulting data frame
print(sector_project_type_counts)

```

  
##Plot 28: First and Fourth Quartiles for Stage Go Ahead to Bank Sanction by size, sector, mode of finance and category


```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(gridExtra)

# Define variable
var <- "days_goahead_sanction"

# Create quartiles based on the variable
df_clean_28 <- df_clean %>%
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories

# Function to calculate counts and percentages
calculate_counts_percentages <- function(df, group_var) {
  df %>%
    group_by_at(c(paste0(var, "_quartile"), group_var)) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count)) %>%
    ungroup()
}

# Calculate counts and percentages for each grouping variable
fixed_cost_counts <- calculate_counts_percentages(df_clean_28, "fixed_cost_range")
sectors_counts <- calculate_counts_percentages(df_clean_28, "sectors")
mode_of_finance_counts <- calculate_counts_percentages(df_clean_28, "mode_of_finance")
general_counts <- calculate_counts_percentages(df_clean_28, "general")

# Function to create a stacked bar plot with labels
create_stacked_bar_plot <- function(df, fill_var, title) {
  ggplot(df, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = .data[[fill_var]])) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 2.5) +
    labs(title = title, 
         x = "Quartile", 
         y = "Number of Applications", 
         fill = fill_var) +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 8))
}

# Create plots
plot_fixed_cost <- create_stacked_bar_plot(fixed_cost_counts, "fixed_cost_range", "Go Ahead to Bank Sanction by Fixed Cost Range")
plot_sectors <- create_stacked_bar_plot(sectors_counts, "sectors", "Go Ahead to Bank Sanction by Sectors")
plot_general <- create_stacked_bar_plot(general_counts, "general", "Go Ahead to Bank Sanction by Subsidy Category")

# Arrange the plots in a 2x2 grid
plot_28 <- grid.arrange(plot_fixed_cost, plot_sectors, plot_general, ncol = 2, nrow = 2)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_28.png", 
       plot = plot_28, width = 12, height = 10, dpi = 300)

# Filter data for the fourth quartile
df_q4 <- df_clean_28 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Count of project_type within each sector in the fourth quartile
sector_project_type_counts <- df_q4 %>%
  group_by(sectors, project_type) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  arrange(sectors, desc(Count))  # Arrange in descending order of Count within each sector

# Print the resulting data frame
print(sector_project_type_counts)

```

##Plot 35: First and Fourth Quartiles for Stage Go Ahead to Completion for self-financed applications
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(gridExtra)

# Define variable
var <- "days_goahead_complete"

# Create quartiles based on the variable and filter for mode_of_finance == 'Self'
df_clean_25 <- df_clean_filtered %>%
  filter(mode_of_finance == 'Self') %>%  # Filter for 'Self' mode of finance
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories

# Function to calculate counts and percentages
calculate_counts_percentages <- function(df, group_var) {
  df %>%
    group_by_at(c(paste0(var, "_quartile"), group_var)) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count)) %>%
    ungroup()
}

# Calculate counts and percentages for each grouping variable
project_cost_counts <- calculate_counts_percentages(df_clean_25, "project_cost_range")
sectors_counts <- calculate_counts_percentages(df_clean_25, "sectors")

# Function to create a stacked bar plot with labels
create_stacked_bar_plot <- function(df, fill_var, title) {
  ggplot(df, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = .data[[fill_var]])) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 2.5) +
    labs(title = title, 
         x = "Quartile", 
         y = "Number of Applications", 
         fill = fill_var) +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 8))
}

# Create plots
plot_project_cost <- create_stacked_bar_plot(project_cost_counts, "project_cost_range", "Stage 2 by Project Cost Range")
plot_sectors <- create_stacked_bar_plot(sectors_counts, "sectors", "Stage 2 by Sectors")

# Arrange the plots in a 2x1 grid
plot_35 <- grid.arrange(plot_project_cost, plot_sectors, ncol = 2, nrow = 1)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_35.png", 
       plot = plot_35, width = 12, height = 10, dpi = 300)

# Filter data for the fourth quartile
df_q4 <- df_clean_25 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Count of project_type within each sector in the fourth quartile
sector_project_type_counts <- df_q4 %>%
  group_by(sectors, project_type) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  arrange(sectors, desc(Count))  # Arrange in descending order of Count within each sector

# Print the resulting data frame
print(sector_project_type_counts)

```
##Plot 36: First and Fourth Quartiles for Stage Go Ahead to Completion for conventional bank loan applications
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(scales)
library(gridExtra)

# Define variable
var <- "days_goahead_complete"

# Create quartiles based on the variable and filter for mode_of_finance == 'Self' and mirror != 1
df_clean_25 <- df_clean_filtered %>%
  filter(mode_of_finance == 'Bank Loan') %>%  # Filter for 'Self' mode of finance
  filter(mirror != 1) %>%  # Filter for mirror not equal to 1
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories


# Function to calculate counts and percentages
calculate_counts_percentages <- function(df, group_var) {
  df %>%
    group_by_at(c(paste0(var, "_quartile"), group_var)) %>%
    summarise(Count = n(), .groups = 'drop') %>%
    group_by_at(paste0(var, "_quartile")) %>%
    mutate(Percentage = Count / sum(Count)) %>%
    ungroup()
}

# Calculate counts and percentages for each grouping variable
project_cost_counts <- calculate_counts_percentages(df_clean_25, "project_cost_range")
sectors_counts <- calculate_counts_percentages(df_clean_25, "sectors")

# Function to create a stacked bar plot with labels
create_stacked_bar_plot <- function(df, fill_var, title) {
  ggplot(df, aes(x = .data[[paste0(var, "_quartile")]], y = Count, fill = .data[[fill_var]])) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(Count, " (", percent(Percentage, accuracy = 0.1), ")")),
              position = position_stack(vjust = 0.5), size = 2.5) +
    labs(title = title, 
         x = "Quartile", 
         y = "Number of Applications", 
         fill = fill_var) +
    theme_minimal() +
    theme(legend.title = element_text(size = 8),
          legend.text = element_text(size = 8))
}

# Create plots
plot_project_cost <- create_stacked_bar_plot(project_cost_counts, "project_cost_range", "Stage 2 by Project Cost Range")
plot_sectors <- create_stacked_bar_plot(sectors_counts, "sectors", "Stage 2 by Sectors")

# Arrange the plots in a 2x1 grid
plot_36 <- grid.arrange(plot_project_cost, plot_sectors, ncol = 2, nrow = 1)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_36.png", 
       plot = plot_36, width = 12, height = 10, dpi = 300)

# Filter data for the fourth quartile
df_q4 <- df_clean_25 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Count of project_type within each sector in the fourth quartile
sector_project_type_counts <- df_q4 %>%
  group_by(sectors, project_type) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  arrange(sectors, desc(Count))  # Arrange in descending order of Count within each sector

# Print the resulting data frame
print(sector_project_type_counts)

```


#----------------------------------------------Misc------------------------------------------------------------------------


#Investigating the third stage of inspection for self financed applications by mof, sector and type
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Load necessary library
library(dplyr)

# Define the variable
var <- "days_complete_src"

# Step 1: Create quartiles for the variable
df_clean_29 <- df_clean %>%
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories

# Step 2: Filter data for the fourth quartile
df_q4 <- df_clean_29 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Step 3: Count of mode_of_finance, sectors, and project_type within the fourth quartile, and calculate median days_complete_src
quartile_summary <- df_q4 %>%
  group_by(mode_of_finance, sectors, project_type) %>%
  summarise(
    Count = n(),
    Median_Days_Complete_Src = median(.data[[var]], na.rm = TRUE),  # Median days for days_complete_src
    .groups = 'drop'
  ) %>%
  arrange(mode_of_finance, sectors, desc(Count))  # Arrange in descending order of Count within each group

# Print the resulting data frame
print(quartile_summary)


```

###...by location
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Step 1: Create quartiles for the variable
df_clean_29 <- df_clean %>%
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories

# Step 2: Filter data for the fourth quartile
df_q4 <- df_clean_29 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Step 3: Count the number of observations in each district for the fourth quartile
district_counts_q4 <- df_q4 %>%
  group_by(district) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(desc(count))  # Arrange in descending order by count

# Display the result
print(district_counts_q4)

```

#Count and list of project types in Agri-engineering
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Filter, count, and arrange in one step
df_clean %>%
  filter(as.numeric(project_sector) == 1) %>%
  group_by(project_sector, project_type) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(desc(count)) %>%
  print()
```



#Investigating the fourth stage of subsidy release for self financed applications 
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Define the variable
var <- "days_src_subsidy"

# Step 1: Create quartiles for the variable
df_clean_30 <- df_clean %>%
  mutate(!!paste0(var, "_quartile") := cut(
    .data[[var]], 
    breaks = quantile(.data[[var]], probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), 
    include.lowest = TRUE, 
    labels = c("Q1", "Q2", "Q3", "Q4")
  )) %>%
  filter(!is.na(.data[[paste0(var, "_quartile")]]))  # Exclude NA quartile categories

# Step 2: Filter data for the fourth quartile
df_q4 <- df_clean_30 %>%
  filter(.data[[paste0(var, "_quartile")]] == "Q4")

# Step 3: Count of mode_of_finance, sectors, and project_type within the fourth quartile
quartile_summary <- df_q4 %>%
  group_by(mode_of_finance, sectors, project_type) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  arrange(mode_of_finance, sectors, desc(Count))  # Arrange in descending order of Count within each group

# Print the resulting data frame
print(quartile_summary)
```
 
#Project types with zero goahead to completion days
```{r}
library(dplyr)

# Filter rows where days_goahead_complete is zero and group by project_type
zero_days_projects <- df_clean_filtered %>%
  filter(days_goahead_complete == 0) %>%
  group_by(project_type) %>%
  summarize(count = n())  # Count the number of occurrences for each project type

# Print the result
print(zero_days_projects)

```
 
  
  
#Quartiles for Stage 3 by district
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(dplyr)
library(tidyr)

# Add a quartile column for days_complete_src
df_quartiles <- df_clean_filtered %>%
  mutate(quartile = ntile(days_complete_src, 4))  # Split into 4 quartiles

# Group by district and quartile, then count the number of projects
projects_by_quartile <- df_quartiles %>%
  filter(!is.na(quartile)) %>%  # Remove rows where quartile is NA
  group_by(district, quartile) %>%
  summarize(project_count = n(), .groups = 'drop')

# Pivot to wide format
projects_wide <- projects_by_quartile %>%
  pivot_wider(names_from = quartile, values_from = project_count, 
              names_prefix = "Q") %>%
  replace(is.na(.), 0)  # Replace NA values with 0 for districts with no projects in certain quartiles

# Arrange by descending order of quartile 4 (Q4)
projects_wide <- projects_wide %>%
  arrange(desc(Q4))

# Print the final wide format data
print(projects_wide)




```

Quartiles for Stage 4 by district
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(dplyr)
library(tidyr)

# Add a quartile column for days_complete_src
df_quartiles <- df_clean_filtered %>%
  mutate(quartile = ntile(days_src_subsidy, 4))  # Split into 4 quartiles

# Group by district and quartile, then count the number of projects
projects_by_quartile <- df_quartiles %>%
  filter(!is.na(quartile)) %>%  # Remove rows where quartile is NA
  group_by(district, quartile) %>%
  summarize(project_count = n(), .groups = 'drop')

# Pivot to wide format
projects_wide <- projects_by_quartile %>%
  pivot_wider(names_from = quartile, values_from = project_count, 
              names_prefix = "Q") %>%
  replace(is.na(.), 0)  # Replace NA values with 0 for districts with no projects in certain quartiles

# Arrange by descending order of quartile 4 (Q4)
projects_wide <- projects_wide %>%
  arrange(desc(Q4))

# Print the final wide format data
print(projects_wide)
```

#Projects in Stage 3 in Kendrapara
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(dplyr)

# Filter for district 17 and completed projects, and select relevant columns
projects_district_17_complete <- df_clean %>%
  filter(district == "KENDRAPARA", completion == 1) %>%
  select(district, project_sector, project_type, mode_of_finance, days_complete_src)

# Print the result
print(projects_district_17_complete)



```
#Completed Projects by district
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(dplyr)

# Filter for completed projects (completion == 1) and group by district
completed_projects_by_district <- df_clean %>%
  filter(completion == 1) %>%
  group_by(district) %>%
  summarise(count_completed = n()) %>%
  arrange(desc(count_completed))

# Calculate the total number of completed projects
total_completed <- sum(completed_projects_by_district$count_completed)

# Add a row for total count of completed projects
completed_projects_with_total <- bind_rows(
  completed_projects_by_district,
  data.frame(district = "Total", count_completed = total_completed)
)

# Display the resulting data frame
print(completed_projects_with_total)

```



#Stages of application in the Completion Stage (after go ahead approval)(Bank and Mirror)
Finding: There are problems with the sanction_date
Mode of Finance: Bank Loan
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count observations where go_ahead_date_posix is non-NA and mode_of_finance is "Bank Loan"
bankloan <- df_clean %>%
  filter(!is.na(go_ahead_date_posix) & mode_of_finance == "Bank Loan") %>%
  summarise(count = n())

# Display the result
print(bankloan)
```
Mode of Finance: Self
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count observations where go_ahead_date_posix is non-NA and mode_of_finance is "Bank Loan"
self <- df_clean %>%
  filter(!is.na(go_ahead_date_posix) & mode_of_finance == "Self") %>%
  summarise(count = n())

# Display the result
print(self)
```


Within Bank Loan:

Mirror account 
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count observations with the specified conditions, including completion == 0
mirror <- df_clean %>%
  filter(!is.na(go_ahead_date_posix) & 
         mode_of_finance == "Bank Loan" & 
         manger_finance_approve %in% c(1, 2)) %>%  # Close the filter condition
  summarise(count = n())

# Display the result
print(mirror)

```
 
Bank Loan 
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count observations with the specified conditions
loan_bank <- df_clean %>%
  filter(!is.na(go_ahead_date_posix) & 
         mode_of_finance == "Bank Loan" & 
         is.na(manger_finance_approve)) %>%
  summarise(count = n())

# Display the result
print(loan_bank)

```

Bank Loan sanctioned and project incomplete
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count observations with the specified conditions
loan_sanction <- df_clean %>%
  filter(!is.na(go_ahead_date_posix) & 
         mode_of_finance == "Bank Loan" & 
         completion == 0 & 
         !is.na(sanction_date_posix)) %>%
  summarise(count = n())

# Display the result
print(loan_sanction)

```

Bank Loan sanctioned
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count observations with the specified conditions
loan_sanction <- df_clean %>%
  filter(!is.na(go_ahead_date_posix) & 
         mode_of_finance == "Bank Loan" & 
         !is.na(sanction_date_posix)) %>%
  summarise(count = n())

# Display the result
print(loan_sanction)

```




Mirror Account approved and project incomplete
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count observations with the specified conditions, including completion == 1 and non-NA advance_cis_sanction_date_posix
mirror_approve <- df_clean %>%
  filter(!is.na(go_ahead_date_posix) & 
         mode_of_finance == "Bank Loan" & 
         completion == 1 & 
         !is.na(advance_cis_sanction_date_posix)) %>%
  summarise(count = n())

# Display the result
print(mirror_approve)

```


Self but project not completed 
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count observations with the specified conditions
self_project_count <- df_clean %>%
  filter(!is.na(go_ahead_date_posix) & 
         mode_of_finance == "Self" & 
         completion == 0) %>%
  summarise(count = n())

# Display the result
print(self_project_count)

```
 
 
 
 
#-------------------Density plots for major stages------------------------------
 
#Plot for first stage, third and fourth
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}

library(ggplot2)
library(dplyr)

# Variables, benchmarks, benchmark labels, and titles
variables <- c("days_reg_goahead", "days_complete_src", "days_src_subsidy")
benchmarks <- c(52, 80, 7)  # Benchmarks for each variable
benchmark_labels <- c("52", "80", "7")  # Labels for benchmark lines
titles <- c("Stage 1: Registration to Go Ahead", 
            "Stage 3: Completion to SRC", 
            "Stage 4: SRC to Subsidy Release")

# Custom colors for the lines
line_colors <- c("Median" = "blue", "Benchmark" = "red")

# Set line widths for the median and benchmark
line_width <- 0.5

# Font size for text labels
medium_font_size <- 4

# Set font size for the axis text
axis_text_size <- 12  # Modify this value to change the axis font size

# Output directory for saving plots
output_dir <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\"  # Make sure this directory exists or create it

# Loop through each variable and create a plot
for (i in seq_along(variables)) {
  
  # Filter data for the current variable, excluding NAs and negative values
  df_filtered <- df_clean_filtered %>%
    filter(!is.na(.data[[variables[i]]]) & .data[[variables[i]]] >= 0)
  
  # Calculate the median for the current variable
  median_value <- round(median(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  
  # Create the plot
  p <- ggplot(df_filtered, aes(x = .data[[variables[i]]])) +
    geom_histogram(aes(y = ..density..), binwidth = 1, fill = "lightblue", alpha = 0.5) +  # Histogram with density
    geom_density(color = "darkblue", size = 1) +  # Overlay density plot
    geom_vline(aes(xintercept = median_value, color = "Median"), 
               linetype = "solid", size = line_width, show.legend = TRUE) +  # Median line with legend
    geom_vline(aes(xintercept = benchmarks[i], color = "Benchmark"), 
               linetype = "solid", size = line_width, show.legend = TRUE) +  # Benchmark line with legend
    scale_color_manual(name = "Lines", values = line_colors) +  # Custom color for vlines
    geom_text(aes(x = median_value, y = 0, label = paste("", median_value)), 
              vjust = 1, color = "blue", size = 5) +  # Label for median
    geom_text(aes(x = benchmarks[i], y = 0, label = benchmark_labels[i]), 
              vjust = -1, color = "red", size = 5) +  # Label for benchmark
    labs(
      title = titles[i],
      x = "Number of Days",
      y = "Density"
    ) +
    scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +  # Density labels to two decimal places
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14),
      axis.text.x = element_text(size = 14),  # Set x-axis font size
      axis.text.y = element_text(size = 14),  # Set y-axis font size
      legend.position = "top",  # Move legend to the top
      legend.title = element_text(size = 14),  # Adjust legend title size
      legend.text = element_text(size = 14),   # Adjust legend text size
      panel.grid.major = element_blank(),  # Remove major gridlines
      panel.grid.minor = element_blank()   # Remove minor gridlines
    )  # Remove gridlines
  
  # Save each plot to a file (e.g., as PNG)
  ggsave(filename = paste0(output_dir, "plot_", variables[i], ".png"), plot = p, width = 8, height = 6)
}

```

 
#Plots for second stage - bank, mirror [with break ups] and Self

Making a new variable mirror for mirror account applications
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
# Create the new variable `mirror`
df_clean_filtered <- df_clean_filtered %>%
  mutate(mirror = ifelse(as.character(manger_finance_approve) %in% c("1", "2"), 1, 0))
```

 
##Bank Loan

```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(ggplot2)
library(dplyr)

# Variables, titles, and benchmarks
variables <- c("days_goahead_sanction", "days_sanction_complete")
titles <- c("Stage 2a: Go Ahead to Bank Sanction", "Stage 2b: Bank Sanction to Completion")

# Custom colors for the lines
line_colors <- c("Median" = "blue")

# Set line widths for the median
line_width <- 0.5

# Font size for text labels
medium_font_size <- 4

# Output directory for saving plots
output_dir <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\"  # Make sure this directory exists or create it

# Initialize an empty data frame to store summary statistics
summary_stats <- data.frame(
  Variable = character(),
  Median = numeric(),
  Min = numeric(),
  Max = numeric(),
  stringsAsFactors = FALSE
)

# Loop through each variable and create a plot
for (i in seq_along(variables)) {
  
  # Filter data for the current variable, excluding NAs and negative values, mode_of_finance = "Bank Loan", and mirror != 1
  df_filtered <- df_clean_filtered %>%
    filter(!is.na(.data[[variables[i]]]) & 
           .data[[variables[i]]] >= 0 & 
           mode_of_finance == "Bank Loan" & 
           mirror != 1)
  
  # Calculate the median, min, and max for the current variable
  median_value <- round(median(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  min_value <- round(min(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  max_value <- round(max(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  
  # Append the calculated statistics to the summary data frame
  summary_stats <- rbind(summary_stats, data.frame(
    Variable = variables[i],
    Median = median_value,
    Min = min_value,
    Max = max_value
  ))
  
  # Calculate the number of observations
  num_obs <- nrow(df_filtered)
  
  # Create the plot
  p <- ggplot(df_filtered, aes(x = .data[[variables[i]]])) +
    geom_histogram(aes(y = ..density..), binwidth = 1, fill = "lightblue", alpha = 0.5) +  # Histogram with density
    geom_density(color = "darkblue", size = 1) +  # Overlay density plot
    geom_vline(aes(xintercept = median_value, color = "Median"), 
               linetype = "solid", size = line_width, show.legend = FALSE) +  # Median line with no legend
    scale_color_manual(name = "Lines", values = line_colors) +  # Custom color for vlines
    geom_text(aes(x = median_value, y = 0, label = paste("", median_value)), 
              vjust = -1, color = "blue", size = medium_font_size) +  # Label for median
    labs(
      title = titles[i],
      x = "Number of Days",
      y = "Density"
    ) +
    scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +  # Density labels to two decimal places
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14),
      axis.text.x = element_text(size = 14),  # Set x-axis font size
      axis.text.y = element_text(size = 14),  # Set y-axis font size
      legend.position = "top",  # Move legend to the top
      legend.title = element_text(size = 14),  # Adjust legend title size
      legend.text = element_text(size = 14),   # Adjust legend text size
      panel.grid.major = element_blank(),  # Remove major gridlines
      panel.grid.minor = element_blank()   # Remove minor gridlines
    )  
  # Save each plot to a file (e.g., as PNG)
  ggsave(filename = paste0(output_dir, "bank_plot_", variables[i], ".png"), plot = p, width = 8, height = 6)
}

# Print the summary statistics data frame
print(summary_stats)



```

 
##Mirror Account
 
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(ggplot2)
library(dplyr)

# Variables, titles, and benchmarks
variables <- c("days_goahead_sanction", "days_sanction_cis_sanction", "days_cis_sanction_complete")
titles <- c("Stage 2a: Go Ahead to Bank Sanction", 
            "Stage 2b: Bank Sanction to Advance CIS Sanction", 
            "Stage 2c: Advance CIS Sanction to Completion")

# Custom colors for the lines
line_colors <- c("Median" = "blue")

# Set line widths for the median
line_width <- 0.5

# Font size for text labels
medium_font_size <- 4

# Output directory for saving plots
output_dir <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\"  # Make sure this directory exists or create it

# Initialize an empty data frame to store summary statistics
summary_stats <- data.frame(
  Variable = character(),
  Median = numeric(),
  Min = numeric(),
  Max = numeric(),
  stringsAsFactors = FALSE
)

# Loop through each variable and create a plot
for (i in seq_along(variables)) {
  
  # Filter data for the current variable, excluding NAs and negative values, and mirror == 1
  df_filtered <- df_clean_filtered %>%
    filter(!is.na(.data[[variables[i]]]) & 
           .data[[variables[i]]] >= 0 & 
           mirror == 1)
  
  # Calculate the median, min, and max for the current variable
  median_value <- round(median(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  min_value <- round(min(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  max_value <- round(max(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  
  # Append the calculated statistics to the summary data frame
  summary_stats <- rbind(summary_stats, data.frame(
    Variable = variables[i],
    Median = median_value,
    Min = min_value,
    Max = max_value
  ))
  
  # Calculate the number of observations
  num_obs <- nrow(df_filtered)
  
  # Create the plot
  p <- ggplot(df_filtered, aes(x = .data[[variables[i]]])) +
    geom_histogram(aes(y = ..density..), binwidth = 1, fill = "lightblue", alpha = 0.5) +  # Histogram with density
    geom_density(color = "darkblue", size = 1) +  # Overlay density plot
    geom_vline(aes(xintercept = median_value, color = "Median"), 
               linetype = "solid", size = line_width, show.legend = FALSE) +  # Median line with no legend
    scale_color_manual(name = "Lines", values = line_colors) +  # Custom color for vlines
    geom_text(aes(x = median_value, y = 0, label = paste("", median_value)), 
              vjust = -1, color = "blue", size = medium_font_size) +  # Label for median
    labs(
      title = titles[i],
      x = "Number of Days",
      y = "Density"
    ) +
    scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +  # Density labels to two decimal places
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5),
      legend.position = "none",  # Remove legend
      panel.grid.major = element_blank(),  # Remove major gridlines
      panel.grid.minor = element_blank()   # Remove minor gridlines
    )  # Remove gridlines
  
  # Save each plot to a file (e.g., as PNG)
  ggsave(filename = paste0(output_dir, "mirror_plot_", variables[i], ".png"), plot = p, width = 8, height = 6)
}

# Print the summary statistics data frame
print(summary_stats)


```
 
 
```{r}
# Create a new data frame with the specified conditions
df_mirror_complete <- df_clean_filtered %>%
  filter(mirror == 1 & !is.na(date_of_completion_posix))

# View the new data frame
print(df_mirror_complete)
```
 
##Plot 34: Self
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(ggplot2)
library(dplyr)

# Variables, titles, and benchmarks
variables <- c("days_goahead_complete")
titles <- c("Self Finance")
benchmarks <- 730  # Benchmark for "days_goahead_complete"

# Custom colors for the lines
line_colors <- c("Median" = "blue", "Benchmark" = "red")

# Set line widths for the median and benchmark
line_width <- 0.75

# Create a list to store summary statistics data frames for all variables
summary_stats_list <- list()

# Loop through each variable and create a plot
for (i in seq_along(variables)) {
  
  # Convert mode_of_finance to character if necessary
  df_filtered <- df_clean_filtered %>%
    filter(!is.na(.data[[variables[i]]]) & 
           .data[[variables[i]]] >= 0 & 
           as.character(mode_of_finance) == "Self") 

  # Calculate summary statistics for the current variable
  mean_value <- round(mean(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  median_value <- round(median(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  min_value <- round(min(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  max_value <- round(max(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  num_obs <- nrow(df_filtered)
  
  # Create a data frame for the summary statistics
  summary_stats <- data.frame(
    Variable = variables[i],
    Mean = mean_value,
    Median = median_value,
    Min = min_value,
    Max = max_value,
    Num_Observations = num_obs
  )
  
  # Append the summary statistics data frame to the list
  summary_stats_list[[i]] <- summary_stats
  
  # Create the plot
plot_34 <- ggplot(df_filtered, aes(x = .data[[variables[i]]])) +
  # Histogram with density
  geom_histogram(aes(y = ..density..), 
                 binwidth = 1, 
                 fill = "lightblue", 
                 alpha = 0.5) +  
  
  # Overlay density plot
  geom_density(color = "darkblue", size = 1) +  
  
  # Median line
  geom_vline(aes(xintercept = median_value, color = "Median"), 
             linetype = "dashed", size = line_width, show.legend = FALSE) +  
  
  # Benchmark line
  geom_vline(aes(xintercept = benchmarks, color = "Benchmark"), 
             linetype = "solid", size = line_width, show.legend = FALSE) +  
  
  # Custom colors for vlines
  scale_color_manual(name = "Lines", values = line_colors) +  
  
  # Label for median
  geom_text(aes(x = median_value, 
                y = 0, 
                label = paste0("", median_value)), 
            vjust = -1, 
            color = "blue", 
            size = 8) +  
  
  # Label for benchmark
  geom_text(aes(x = benchmarks, 
                y = 0, 
                label = "730"), 
            vjust = -1, 
            color = "red", 
            size = 8) +  
  
  # Labels and titles
  labs(
    title = titles[i],
    x = "Number of Days",
    y = "Density"
  ) +
  
  # Density labels to two decimal places
  scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +  
  
  # Theme and customization
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 22, face = "bold"),  # Center title with size and bold
    axis.title.x = element_text(size = 18),  # Customize x-axis title size
    axis.title.y = element_text(size = 18),  # Customize y-axis title size
    axis.text.x = element_text(size = 18),  # Customize x-axis text size
    axis.text.y = element_text(size = 18),  # Customize y-axis text size
    panel.grid.major = element_line(color = "gray", linetype = "dotted"),  # Major gridlines style
    panel.grid.minor = element_line(color = "lightgray", linetype = "dotted"),  # Minor gridlines style
    legend.position = "none"  # Remove legend
  ) 


  
}

# Combine all summary statistics into a single data frame
summary_stats_df <- bind_rows(summary_stats_list)

# Display the summary statistics data frame
print(summary_stats_df)

# Display the plot (last plot created in the loop)
print(plot_34)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_34.png", 
       plot = plot_34, width = 12, height = 10, dpi = 300)


```


#Plots for second stage [without break ups]

## Plot 32: Bank Loan
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(ggplot2)
library(dplyr)

# Variables, titles, and benchmarks
variables <- c("days_goahead_complete")
titles <- c("Conventional Bank Loan")
benchmarks <- 730  # Benchmark for "days_goahead_complete"

# Custom colors for the lines
line_colors <- c("Median" = "blue", "Benchmark" = "red")

# Set line widths for the median and benchmark
line_width <- 0.75

# Create a list to store summary statistics data frames for all variables
summary_stats_list <- list()

# Loop through each variable and create a plot
for (i in seq_along(variables)) {
  
  # Convert mode_of_finance to character if necessary
  df_filtered <- df_clean_filtered %>%
    filter(!is.na(.data[[variables[i]]]) & 
           .data[[variables[i]]] >= 0 & 
           as.character(mode_of_finance) == "Bank Loan" &  # Filter correctly on factor
           mirror != 1)
  
  # Calculate summary statistics for the current variable
  mean_value <- round(mean(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  median_value <- round(median(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  min_value <- round(min(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  max_value <- round(max(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  num_obs <- nrow(df_filtered)
  
  # Create a data frame for the summary statistics
  summary_stats <- data.frame(
    Variable = variables[i],
    Mean = mean_value,
    Median = median_value,
    Min = min_value,
    Max = max_value,
    Num_Observations = num_obs
  )
  
  # Append the summary statistics data frame to the list
  summary_stats_list[[i]] <- summary_stats
  
  # Create the plot
plot_32 <- ggplot(df_filtered, aes(x = .data[[variables[i]]])) +
  # Histogram with density
  geom_histogram(aes(y = ..density..), 
                 binwidth = 1, 
                 fill = "lightblue", 
                 alpha = 0.5) +  
  
  # Overlay density plot
  geom_density(color = "darkblue", size = 1) +  
  
  # Median line
  geom_vline(aes(xintercept = median_value, color = "Median"), 
             linetype = "dashed", size = line_width, show.legend = FALSE) +  
  
  # Benchmark line
  geom_vline(aes(xintercept = benchmarks, color = "Benchmark"), 
             linetype = "solid", size = line_width, show.legend = FALSE) +  
  
  # Custom colors for vlines
  scale_color_manual(name = "Lines", values = line_colors) +  
  
  # Label for median
  geom_text(aes(x = median_value, 
                y = 0, 
                label = paste0("", median_value)), 
            vjust = -1, 
            color = "blue", 
            size = 8) +  
  
  # Label for benchmark
  geom_text(aes(x = benchmarks, 
                y = 0, 
                label = "730"), 
            vjust = -1, 
            color = "red", 
            size = 8) +  
  
  # Labels and titles
  labs(
    title = titles[i],
    x = "Number of Days",
    y = "Density"
  ) +
  
  # Density labels to two decimal places
  scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +  
  
  # Theme and customization
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 22, face = "bold"),  # Center title with size and bold
    axis.title.x = element_text(size = 18),  # Customize x-axis title size
    axis.title.y = element_text(size = 18),  # Customize y-axis title size
    axis.text.x = element_text(size = 18),  # Customize x-axis text size
    axis.text.y = element_text(size = 18),  # Customize y-axis text size
    panel.grid.major = element_line(color = "gray", linetype = "dotted"),  # Major gridlines style
    panel.grid.minor = element_line(color = "lightgray", linetype = "dotted"),  # Minor gridlines style
    legend.position = "none"  # Remove legend
  ) 


  
}

# Combine all summary statistics into a single data frame
summary_stats_df <- bind_rows(summary_stats_list)

# Display the summary statistics data frame
print(summary_stats_df)

# Display the plot (last plot created in the loop)
print(plot_32)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_32.png", 
       plot = plot_32, width = 12, height = 10, dpi = 300)


```



##Plot 33: Mirror Account
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(ggplot2)
library(dplyr)

# Variables, titles, and benchmarks
variables <- c("days_goahead_complete")
titles <- c("Mirror Account")
benchmarks <- 730  # Benchmark for "days_goahead_complete"

# Custom colors for the lines
line_colors <- c("Median" = "blue", "Benchmark" = "red")

# Set line widths for the median and benchmark
line_width <- 0.75

# Create a list to store summary statistics data frames for all variables
summary_stats_list <- list()

# Loop through each variable and create a plot
for (i in seq_along(variables)) {
  
  # Convert mode_of_finance to character if necessary
  df_filtered <- df_clean_filtered %>%
    filter(!is.na(.data[[variables[i]]]) & 
           .data[[variables[i]]] >= 0 & 
           as.character(mode_of_finance) == "Bank Loan" &  # Filter correctly on factor
           mirror == 1)
  
  # Calculate summary statistics for the current variable
  mean_value <- round(mean(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  median_value <- round(median(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  min_value <- round(min(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  max_value <- round(max(df_filtered[[variables[i]]], na.rm = TRUE), 0)
  num_obs <- nrow(df_filtered)
  
  # Create a data frame for the summary statistics
  summary_stats <- data.frame(
    Variable = variables[i],
    Mean = mean_value,
    Median = median_value,
    Min = min_value,
    Max = max_value,
    Num_Observations = num_obs
  )
  
  # Append the summary statistics data frame to the list
  summary_stats_list[[i]] <- summary_stats
  
  # Create the plot
plot_33 <- ggplot(df_filtered, aes(x = .data[[variables[i]]])) +
  # Histogram with density
  geom_histogram(aes(y = ..density..), 
                 binwidth = 1, 
                 fill = "lightblue", 
                 alpha = 0.5) +  
  
  # Overlay density plot
  geom_density(color = "darkblue", size = 1) +  
  
  # Median line
  geom_vline(aes(xintercept = median_value, color = "Median"), 
             linetype = "dashed", size = line_width, show.legend = FALSE) +  
  
  # Benchmark line
  geom_vline(aes(xintercept = benchmarks, color = "Benchmark"), 
             linetype = "solid", size = line_width, show.legend = FALSE) +  
  
  # Custom colors for vlines
  scale_color_manual(name = "Lines", values = line_colors) +  
  
  # Label for median
  geom_text(aes(x = median_value, 
                y = 0, 
                label = paste0("", median_value)), 
            vjust = -1, 
            color = "blue", 
            size = 8) +  
  
  # Label for benchmark
  geom_text(aes(x = benchmarks, 
                y = 0, 
                label = "730"), 
            vjust = -1, 
            color = "red", 
            size = 8) +  
  
  # Labels and titles
  labs(
    title = titles[i],
    x = "Number of Days",
    y = "Density"
  ) +
  
  # Density labels to two decimal places
  scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +  
  
  # Theme and customization
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 22, face = "bold"),  # Center title with size and bold
    axis.title.x = element_text(size = 18),  # Customize x-axis title size
    axis.title.y = element_text(size = 18),  # Customize y-axis title size
    axis.text.x = element_text(size = 18),  # Customize x-axis text size
    axis.text.y = element_text(size = 18),  # Customize y-axis text size
    panel.grid.major = element_line(color = "gray", linetype = "dotted"),  # Major gridlines style
    panel.grid.minor = element_line(color = "lightgray", linetype = "dotted"),  # Minor gridlines style
    legend.position = "none"  # Remove legend
  ) 


  
}

# Combine all summary statistics into a single data frame
summary_stats_df <- bind_rows(summary_stats_list)

# Display the summary statistics data frame
print(summary_stats_df)

# Display the plot (last plot created in the loop)
print(plot_33)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_33.png", 
       plot = plot_33, width = 12, height = 10, dpi = 300)

```
#----------------------------------------------------------------------------------------

#Data frame for values below and above benchmarks for major stages
```{r, echo=FALSE, message=FALSE, warning=FALSE, results='markup'}
library(dplyr)

# Variables and benchmarks
variables <- c("days_reg_goahead", "days_goahead_complete", "days_complete_src", "days_src_subsidy")
benchmarks <- c(52, 730, 80, 7)

# Initialize an empty list to store the results for each variable
results_list <- list()

# Loop through each variable and calculate counts and percentages
for (i in seq_along(variables)) {
  
  # Filter data for the current variable, excluding NAs
  df_filtered <- df_clean_filtered %>%
    filter(!is.na(.data[[variables[i]]]))
  
  # Calculate the total number of observations
  total_count <- nrow(df_filtered)
  
  # Count observations below and above the benchmark
  count_below <- sum(df_filtered[[variables[i]]] < benchmarks[i], na.rm = TRUE)
  count_above <- sum(df_filtered[[variables[i]]] >= benchmarks[i], na.rm = TRUE)
  
  # Calculate percentages
  percent_below <- (count_below / total_count) * 100
  percent_above <- (count_above / total_count) * 100
  
  # Create a data frame for the current variable
  results_list[[i]] <- data.frame(
    Variable = variables[i],
    Below_Benchmark_Count = count_below,
    Below_Benchmark_Percent = round(percent_below, 2),
    Above_Benchmark_Count = count_above,
    Above_Benchmark_Percent = round(percent_above, 2)
  )
}

# Combine the results into a single data frame
results_df <- bind_rows(results_list)

# View the final dataset
print(results_df)

```

 
#Days between registration and subsidy release
```{r}
# Calculate days between registration_date_posix and subsidy_release_posix and apply ceiling
df_clean_filtered <- df_clean_filtered %>%
  mutate(days_reg_subsidy = ceiling(as.numeric(difftime(subsidy_date_posix, registration_date_posix, units = "days")))) %>%
  filter(days_reg_subsidy >= 0)  # Keep only positive days

# Summary statistics: mean, median, min, and max
summary_stats <- df_clean_filtered %>%
  summarise(
    mean_days = mean(days_reg_subsidy, na.rm = TRUE),
    median_days = median(days_reg_subsidy, na.rm = TRUE),
    min_days = min(days_reg_subsidy, na.rm = TRUE),
    max_days = max(days_reg_subsidy, na.rm = TRUE)
  )

# Print summary statistics
print(summary_stats)
```


#Investigating advance CIS sanction
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(dplyr)

# Count the number of observations where advance_cis_sanction is 1
count_advance_cis_sanction_1 <- df_clean %>% 
  filter(as.numeric(as.character(advance_cis_sanction)) == 1) %>%
  summarise(count = n())

# Output the result
count_advance_cis_sanction_1


```

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Count non-NA observations for subsidy_amount when mirror == 1
non_na_subsidy_count <- df_clean %>%
  filter(mirror == 1) %>%  # Filter rows where mirror == 1
  summarise(non_na_count = sum(!is.na(subsidy_amount)))  # Count non-NA subsidy_amount

# Output the result
non_na_subsidy_count
```

Data frames for mirror account and pure bank loan 
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(dplyr)

# Filter the data for advance_cis_sanction == 1 and select the required columns
filtered_df <- df_clean_filtered %>%
  filter(advance_cis_sanction == 1) %>%  # Filter where advance_cis_sanction is 1
  select(registration_date, project_type, mode_of_finance, advance_cis_sanction_date, manger_finance_approve)

# Display the resulting data frame
print(filtered_df)



# Filter the data for mode_of_finance == "Bank Loan" and manger_finance_approve is not 1 or 2
filtered_df <- df_clean_filtered %>%
  filter(mode_of_finance == "Bank Loan", !manger_finance_approve %in% c(1, 2)) %>%  # Exclude 1 and 2 for manger_finance_approve
  select(registration_date, project_type, mode_of_finance, advance_cis_sanction_date, manger_finance_approve)

# Display the resulting data frame
print(filtered_df)



```

#Plot 29: Spatial distribution of projects above 2 crore

Pie chart for sector share
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Filter projects with fixed_cost greater than 2 crore
df_above_2_crore <- df_clean %>%
  filter(fixed_cost >= 20000000) %>%    # Select projects with fixed_cost above 2 crore
  group_by(sectors) %>%                # Group by sectors
  summarise(count = n(),               # Count the number of projects in each sector
            total_fixed_cost = sum(fixed_cost, na.rm = TRUE))  # Sum of fixed_cost in each sector

# Display the resulting data frame
print(df_above_2_crore)

```






Data frame
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Filter projects with fixed_cost above 1 crore
projects_above_2_crore <- df_clean %>%
  filter(fixed_cost >= 20000000) %>%
  group_by(district) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(desc(count))  # Arrange in descending order by count

# Calculate the total count of projects
total_count <- projects_above_2_crore %>%
  summarise(count = sum(count)) %>%
  mutate(district = "Total")

# Combine the original data frame with the total row
projects_above_2_crore_with_total <- bind_rows(projects_above_2_crore, total_count)

# Display the updated summary data frame
print(projects_above_2_crore_with_total)
```

Join
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Load necessary libraries
library(dplyr)
library(sf)
library(stringdist)

# Read the shapefile
odisha_districts <- st_read("C:\\Users\\Admin\\Documents\\CRFM\\Maps\\OD_district_shp_2\\odisha_district.shp")

# Standardize 'district' names in projects_above_1_crore to match odisha_districts format
projects_above_2_crore <- projects_above_2_crore %>%
  mutate(district = tools::toTitleCase(tolower(trimws(district))))

# Standardize 'district' names in odisha_districts to match the format
odisha_districts <- odisha_districts %>%
  mutate(district = tools::toTitleCase(tolower(trimws(district))))

# Manually update district names in odisha_districts
odisha_districts <- odisha_districts %>%
  mutate(district = case_when(
    district == "Baleshwar" ~ "Balasore",
    district == "Kendujhar" ~ "Keonjhar",
    district == "Subarnapur" ~ "Sonepur",
    district == "Anugul" ~ "Angul",
    district == "Khordha" ~ "Khurdha",
    district == "Nabarangapur" ~ "Nabarangpur",
    district == "Jajapur" ~ "Jajpur",
    district == "Bauda" ~ "Boudh",
    district == "Debagarh" ~ "Deogarh",
    # Add more manual updates if needed
    TRUE ~ district  # Keep other names unchanged
  ))



project_count <- projects_above_2_crore %>%
  group_by(district) %>%
  summarise(count = n(), .groups = 'drop')

# Join odisha_districts with the summarized project count
# No need to include geometry twice, so select geometry only from odisha_districts
final_data_2 <- odisha_districts %>%
  left_join(projects_above_2_crore, by = "district")

projects_above_2_crore <- projects_above_2_crore %>%
  replace_na(list(count = 0))

# Inspect final_data
print(final_data_2)





# Check the number of rows in both dataframes
print(paste("Number of rows in projects_above_2_crore:", nrow(projects_above_2_crore)))
print(paste("Number of rows in odisha_districts:", nrow(odisha_districts)))

# Inspect the first few rows of each dataframe
print("First few rows of projects_above_2_crore:")
print(head(projects_above_2_crore))

print("First few rows of odisha_districts:")
print(head(odisha_districts))

```

Map
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(ggplot2)
library(viridis)  # For color scales

plot_29 <- ggplot(data = final_data_2) +
  geom_sf(aes(fill = count), color = "black") +  # Fill based on 'count' with black boundaries
  scale_fill_gradientn(
    colors = c("lightyellow", "red"),  # Color scale for the data
    na.value = "grey90",  # Set grey color for NA values
    name = "Application Count",  # Name for the legend
    breaks = c(NA, min(final_data_2$count, na.rm = TRUE), max(final_data_2$count, na.rm = TRUE)),
    labels = c("No Data", "", "")  # Custom labels for NA, low, and high values
  ) +
  geom_sf_text(aes(label = district), size = 5, color = "black", fontface = "bold") +  # Add district labels
  theme_minimal() +  # Clean theme
  labs(title = "", 
       caption = "No projects above 2 crores in the grey districts") +  # Add caption for the note
  theme(
    plot.title = element_text(size = 18, face = "bold"),
    plot.subtitle = element_text(size = 10),
    
    # Increased caption size
    plot.caption = element_text(size = 22, face = "italic", hjust = 0.5, vjust = 2),  # Customize caption: italic, centered, larger size
    
    legend.title = element_text(size = 18),
    legend.text = element_text(size = 16),
    legend.key.size = unit(1.5, "cm"),  # Increase the size of the legend key
    axis.text.x = element_blank(),  # Remove x-axis text
    axis.text.y = element_blank(),  # Remove y-axis text
    axis.title.x = element_blank(),  # Remove x-axis title
    axis.title.y = element_blank(),  # Remove y-axis title
    legend.position = "bottom",  # Move legend to the bottom
    plot.margin = margin(t = 10, r = 10, b = 30, l = 10)  # Add space at the bottom for the note
  )

print(plot_29)

# Save the plot to a file
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_29.png", 
       plot = plot_29, width = 12, height = 10, dpi = 300)
      




```


Plot 29: Fixed cost size composition for each sector
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Example data frame preparation: Assuming df_clean contains 'sectors' and 'fixed_cost_range'
df_summary <- df_clean %>%
  group_by(sectors, fixed_cost_range) %>%
  summarise(count = n()) %>%
  ungroup()

# Check the summary data frame
print(df_summary)


# Stacked bar chart
ggplot(df_summary, aes(x = sectors, y = count, fill = fixed_cost_range)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Fixed Cost Range Composition by Sector",
       x = "Sector",
       y = "Count",
       fill = "Fixed Cost Range") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


#Plot 30: Line graph for growth in bank financed applications
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(ggplot2)
library(dplyr)
library(lubridate)
library(tidyr)

# Ensure registration_date_posix is a Date object
df_clean_filtered$registration_date_posix <- as.POSIXct(df_clean_filtered$registration_date_posix, origin = "1970-01-01", tz = "UTC")

# Extract month and year from the date
df_clean_filtered <- df_clean_filtered %>%
  mutate(month_year = floor_date(registration_date_posix, "month"))

# Filter for mode_of_finance == "Bank Loan" or "Self"
df_filtered <- df_clean_filtered %>%
  filter(mode_of_finance %in% c("Bank Loan", "Self"))

# Aggregate data to get the monthly count of projects for each mode_of_finance
df_monthly_counts <- df_filtered %>%
  group_by(month_year, mode_of_finance) %>%
  summarise(count = n(), .groups = 'drop')

# Ensure there is a row for each month and mode_of_finance even if no projects were registered in that month
df_monthly_counts <- df_monthly_counts %>%
  complete(month_year = seq(min(month_year), max(month_year), by = "month"), mode_of_finance, fill = list(count = 0)) %>%
  arrange(month_year, mode_of_finance)

# Calculate cumulative counts for each mode_of_finance
df_cumulative <- df_monthly_counts %>%
  group_by(mode_of_finance) %>%
  mutate(cumulative_count = cumsum(count))

# Ensure month_year is of Date class
df_cumulative$month_year <- as.Date(df_cumulative$month_year)

# Define the vertical line date
vline_date <- as.Date("2023-08-01")

plot_30 <- ggplot(df_cumulative, aes(x = month_year, y = cumulative_count, color = mode_of_finance)) +
  geom_line(size = 1) +                                                   # Customize line width
  geom_vline(xintercept = as.numeric(vline_date), linetype = "dashed",     # Vertical dashed line
             color = "black", size = 0.8) +                                # Changed to black and adjusted size
  scale_x_date(date_labels = "%b %Y", date_breaks = "4 months") +          # X-axis labels with month-year and breaks
  labs(                                                                    # No title, custom axis labels
    x = "",
    y = "Number of Applications",
    color = "Mode of Finance"
  ) +
  annotate("text", x = vline_date - 30, y = max(df_cumulative$cumulative_count) * 0.9, 
           label = "Introduction of Mirror A/c", color = "black", angle = 360, vjust = -0.5, hjust = 1, size = 7) + # Annotate text
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5),                   # X-axis labels are now horizontal
    axis.text = element_text(size = 18, color = "black"),                 # Customize axis text size and color
    axis.title.x = element_text(size = 18, face = "bold", margin = margin(t = 10)), # Increase gap between x-axis title and labels
    axis.title.y = element_text(size = 18, face = "bold", margin = margin(r = 10)), # Increase gap between y-axis title and labels
    panel.grid = element_blank(),                                         # Remove all gridlines
    legend.title = element_text(size = 22, face = "bold"),                # Customize legend title
    legend.text = element_text(size = 22),                                # Customize legend text
    legend.position = c(0.20, 0.75),                                      # Move legend inside plot
    legend.background = element_rect(fill = alpha("white", 0.8)),         # Transparent background for the legend
    legend.box.background = element_rect(color = "black", size = 0.5),    # Add border to the legend box
    legend.direction = "vertical",                                        # Legend stacked vertically
    plot.margin = margin(t = 20, r = 30, b = 20, l = 30)                  # Add margins (top, right, bottom, left)
  )

print(plot_30)

# Save the plot with adjusted margins
ggsave("C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Plots\\Plot_30.png", 
       plot = plot_30, width = 12, height = 10, dpi = 300)


```

# Plot 31: Line graph for share of bank applications in total

```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
library(ggplot2)
library(dplyr)
library(lubridate)

# Ensure registration_date_posix is a Date object
df_clean_filtered$registration_date_posix <- as.POSIXct(df_clean_filtered$registration_date_posix, origin = "1970-01-01", tz = "UTC")

# Extract month and year from the date
df_clean_filtered <- df_clean_filtered %>%
  mutate(month_year = floor_date(registration_date_posix, "month"))

# Calculate the total monthly project applications
df_total_counts <- df_clean_filtered %>%
  group_by(month_year) %>%
  summarise(total_count = n(), .groups = 'drop')

# Calculate the monthly bank loan applications
df_bank_loan_counts <- df_clean_filtered %>%
  filter(mode_of_finance == "Bank Loan") %>%
  group_by(month_year) %>%
  summarise(bank_loan_count = n(), .groups = 'drop')

# Merge the two data frames to get total and bank loan counts in one
df_merged <- left_join(df_total_counts, df_bank_loan_counts, by = "month_year")

# Replace NA values in bank_loan_count with 0 (for months with no bank loan applications)
df_merged <- df_merged %>%
  mutate(bank_loan_count = ifelse(is.na(bank_loan_count), 0, bank_loan_count))

# Calculate the share of bank loan applications
df_merged <- df_merged %>%
  mutate(bank_loan_share = (bank_loan_count / total_count) * 100)  # Share in percentage

# Ensure month_year is of Date class
df_merged$month_year <- as.Date(df_merged$month_year)

# Filter out the year 2021
df_merged <- df_merged %>%
  filter(year(month_year) != 2021)

# Limit decimals to one place for bank_loan_share
df_merged <- df_merged %>%
  mutate(bank_loan_share = round(bank_loan_share, 1))

# Add a total row for all months
total_row <- df_merged %>%
  summarise(month_year = as.Date(NA),  # No specific month for total
            total_count = sum(total_count),
            bank_loan_count = sum(bank_loan_count),
            bank_loan_share = round((sum(bank_loan_count) / sum(total_count)) * 100, 1))

# Combine the data with the total row
df_merged_total <- bind_rows(df_merged, total_row)

# Display the resulting data frame
print(df_merged_total)

# Define the vertical line date
vline_date <- as.Date("2023-08-01")


# Plot the share of bank loan applications over time
ggplot(df_merged_total, aes(x = month_year, y = bank_loan_share)) +
  geom_line(size = 1, color = "blue") +
    geom_vline(xintercept = as.numeric(vline_date), linetype = "dashed", color = "red", size = 0.5) +  # Add the vertical dashed line
  scale_x_date(date_labels = "%b %Y", date_breaks = "3 months") +  # Format x-axis labels to show month and year
  labs(
    title = "Share of Bank Loan Applications Over Time",
    x = "Month-Year",
    y = "Share of Bank Loan Applications (%)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )
```

#Investigating DNO Annexure variable
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# Calculate the count of each level/label in dno_annexure
dno_annexure_counts <- df_clean %>%
  count(dno_annexure)

print(dno_annexure_counts)
```
By district
```{r}
# Load necessary libraries
library(dplyr)

# Filter projects where src_date is not NA and group by district
df_grouped_by_district <- df_clean %>%
  filter(!is.na(subsidy_date)) %>%   # Filter out rows where src_date is NA
  group_by(project_cost_range) %>%         # Group by district
  summarise(count = n())         # Count the number of projects in each district

# View the result
print(df_grouped_by_district)

```
By Sector
```{r}
# Filter projects where src_date is not NA and group by district
df_grouped_by_sectors <- df_clean %>%
  filter(!is.na(subsidy_date)) %>%   # Filter out rows where src_date is NA
  group_by(sectors) %>%         # Group by district
  summarise(count = n())         # Count the number of projects in each district

# View the result
print(df_grouped_by_sectors)
```


#--------------------------------------------------  
#Useful data frames  

##Data Frame for all the days variables with other variables
```{r, echo=FALSE, warning=FALSE, message=FALSE, results='markup'}
# List of variables to include in the new data frame
selected_vars <- c("district", "block", "gp", "village", "caste", "gender", "sectors", "project_type", 
                   "project_cost", "fixed_cost", "mode_of_finance", "completion", "fixed_cost_range", 
                   "project_cost_range", "days_reg_blo", "days_blo_dno", "days_dno_collector",
                   "days_collector_apicoldm", "days_apicoldm_goahead", "days_goahead_sanction",
                   "days_sanction_cis_sanction", "days_cis_sanction_complete", "days_sanction_complete",
                   "days_complete_blo_inspect", "days_blo_inspect_dno_comp", "days_dno_comp_admin",
                   "days_admin_src", "days_admin_subsidy", "days_src_subsidy", "days_goahead_complete", 
                   "days_reg_goahead", "days_goahead_complete", "days_complete_src", "days_src_subsidy")

# Subset the df_clean_filtered data frame with the selected variables
df_selected <- df_clean_filtered %>%
  select(all_of(selected_vars))


xl_selected <- "C:\\Users\\Admin\\Box\\1. Agriculture Odisha\\5. MKUY\\8. Sanchit\\Dofiles\\Excel Tables\\df_selected.xlsx"

# Export the data frame to Excel
write_xlsx(df_selected, path = xl_selected)
```
  
  
  
  
  
  
  
  ##